import {
  MediaQuery
} from "./chunk-TB5BDBGC.js";
import {
  ConnectionLineType,
  ConnectionMode,
  MarkerType,
  PanOnScrollMode,
  Position,
  ResizeControlVariant,
  SelectionMode,
  XYDrag,
  XYHandle,
  XYMinimap,
  XYPanZoom,
  XYResizer,
  XY_RESIZER_HANDLE_POSITIONS,
  XY_RESIZER_LINE_POSITIONS,
  addEdge,
  adoptUserNodes,
  areConnectionMapsEqual,
  calculateNodePosition,
  createMarkerIds,
  devWarn,
  elementSelectionKeys,
  errorMessages,
  evaluateAbsolutePosition,
  fitViewport,
  getBezierEdgeCenter,
  getBezierPath,
  getBoundsOfRects,
  getConnectedEdges,
  getConnectionStatus,
  getEdgeCenter,
  getEdgePosition,
  getElementsToRemove,
  getElevatedEdgeZIndex,
  getEventPosition,
  getHostForElement,
  getIncomers,
  getInternalNodesBounds,
  getMarkerId,
  getNodeDimensions,
  getNodeToolbarTransform,
  getNodesBounds,
  getNodesInside,
  getOutgoers,
  getOverlappingArea,
  getSmoothStepPath,
  getStraightPath,
  getViewportForBounds,
  handleConnectionChange,
  infiniteExtent,
  initialConnection,
  isEdgeBase,
  isEdgeVisible,
  isInputDOMNode,
  isMacOs,
  isMouseEvent,
  isNodeBase,
  isNumeric,
  isRectObject,
  mergeAriaLabelConfig,
  nodeHasDimensions,
  nodeToRect,
  panBy,
  pointToRendererPoint,
  rendererPointToPoint,
  shallowNodeData,
  snapPosition,
  updateAbsolutePositions,
  updateConnectionLookup,
  updateNodeInternals
} from "./chunk-46WEM56I.js";
import "./chunk-35YGWFX6.js";
import "./chunk-3ZYLPZAR.js";
import "./chunk-TXLLYXSL.js";
import {
  CLASS,
  STYLE,
  action,
  add_locations,
  append_styles,
  attribute_effect,
  bind_element_size,
  bind_this,
  check_target,
  clsx,
  component,
  create_ownership_validator,
  css_props,
  each,
  if_block,
  init,
  legacy_api,
  log_if_contains_state,
  onDestroy,
  onMount,
  prop,
  rest_props,
  set_attribute,
  set_class,
  set_style,
  snippet,
  spread_props,
  validate_binding,
  validate_each_keys,
  wrap_snippet
} from "./chunk-VPNRNMWF.js";
import "./chunk-U7P2NEEE.js";
import {
  $window,
  FILENAME,
  append,
  apply,
  child,
  comment,
  delegate,
  effect_root,
  effect_tracking,
  event,
  exclude_from_object,
  fallback,
  first_child,
  from_html,
  from_svg,
  get,
  getContext,
  next,
  noop,
  on,
  pop,
  proxy,
  push,
  reset,
  set,
  setContext,
  set_text,
  sibling,
  snapshot,
  state,
  strict_equals,
  tag,
  tag_proxy,
  template_effect,
  text,
  to_array,
  untrack,
  user_derived,
  user_effect,
  user_pre_effect
} from "./chunk-SQH64BMR.js";
import "./chunk-XC45M5LZ.js";
import "./chunk-IFTDSLWF.js";
import {
  __privateAdd,
  __privateGet,
  __publicField
} from "./chunk-3HIFKDCR.js";

// node_modules/@xyflow/svelte/dist/lib/components/Handle/Handle.svelte
Handle[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/Handle/Handle.svelte";
var root = add_locations(from_html(`<div><!></div>`), Handle[FILENAME], [[147, 0]]);
function Handle($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Handle);
  let handleId = prop($$props, "id", 3, null), type = prop($$props, "type", 3, "source"), position = prop($$props, "position", 19, () => Position.Top), isConnectableStart = prop($$props, "isConnectableStart", 3, true), isConnectableEnd = prop($$props, "isConnectableEnd", 3, true), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "type",
      "position",
      "style",
      "class",
      "isConnectable",
      "isConnectableStart",
      "isConnectableEnd",
      "isValidConnection",
      "onconnect",
      "ondisconnect",
      "children"
    ],
    "rest"
  );
  const nodeId = getContext("svelteflow__node_id");
  const isConnectableContext = getContext("svelteflow__node_connectable");
  let isTarget = tag(user_derived(() => strict_equals(type(), "target")), "isTarget");
  let isConnectable = tag(user_derived(() => strict_equals($$props.isConnectable, void 0, false) ? $$props.isConnectable : isConnectableContext.value), "isConnectable");
  let store = useStore();
  let ariaLabelConfig = tag(user_derived(() => store.ariaLabelConfig), "ariaLabelConfig");
  let prevConnections = null;
  user_pre_effect(() => {
    if ($$props.onconnect || $$props.ondisconnect) {
      store.edges;
      let connections = store.connectionLookup.get(`${nodeId}-${type()}${handleId() ? `-${handleId()}` : ""}`);
      if (prevConnections && !areConnectionMapsEqual(connections, prevConnections)) {
        const _connections = connections ?? /* @__PURE__ */ new Map();
        handleConnectionChange(prevConnections, _connections, $$props.ondisconnect);
        handleConnectionChange(_connections, prevConnections, $$props.onconnect);
      }
      prevConnections = new Map(connections);
    }
  });
  let $$d = tag(
    user_derived(() => {
      if (!store.connection.inProgress) {
        return [false, false, false, false, null];
      }
      const { fromHandle, toHandle, isValid } = store.connection;
      const connectingFrom2 = fromHandle && strict_equals(fromHandle.nodeId, nodeId) && strict_equals(fromHandle.type, type()) && strict_equals(fromHandle.id, handleId());
      const connectingTo2 = toHandle && strict_equals(toHandle.nodeId, nodeId) && strict_equals(toHandle.type, type()) && strict_equals(toHandle.id, handleId());
      const isPossibleTargetHandle2 = strict_equals(store.connectionMode, ConnectionMode.Strict) ? strict_equals(fromHandle == null ? void 0 : fromHandle.type, type(), false) : strict_equals(nodeId, fromHandle == null ? void 0 : fromHandle.nodeId, false) || strict_equals(handleId(), fromHandle == null ? void 0 : fromHandle.id, false);
      const valid2 = connectingTo2 && isValid;
      return [
        true,
        connectingFrom2,
        connectingTo2,
        isPossibleTargetHandle2,
        valid2
      ];
    }),
    "[$derived iterable]"
  ), $$array = tag(user_derived(() => to_array(get($$d), 5)), "[$derived iterable]"), connectionInProgress = tag(user_derived(() => get($$array)[0]), "connectionInProgress"), connectingFrom = tag(user_derived(() => get($$array)[1]), "connectingFrom"), connectingTo = tag(user_derived(() => get($$array)[2]), "connectingTo"), isPossibleTargetHandle = tag(user_derived(() => get($$array)[3]), "isPossibleTargetHandle"), valid = tag(user_derived(() => get($$array)[4]), "valid");
  function onConnectExtended(connection) {
    var _a, _b;
    const edge = ((_a = store.onbeforeconnect) == null ? void 0 : _a.call(store, connection)) ?? connection;
    if (!edge) {
      return;
    }
    store.addEdge(edge);
    (_b = store.onconnect) == null ? void 0 : _b.call(store, connection);
  }
  function onpointerdown(event2) {
    const isMouseTriggered = isMouseEvent(event2);
    if (isMouseTriggered && strict_equals(event2.button, 0) || !isMouseTriggered) {
      XYHandle.onPointerDown(event2, {
        handleId: handleId(),
        nodeId,
        isTarget: get(isTarget),
        connectionRadius: store.connectionRadius,
        domNode: store.domNode,
        nodeLookup: store.nodeLookup,
        connectionMode: store.connectionMode,
        lib: "svelte",
        autoPanOnConnect: store.autoPanOnConnect,
        flowId: store.flowId,
        isValidConnection: $$props.isValidConnection ?? store.isValidConnection,
        updateConnection: store.updateConnection,
        cancelConnection: store.cancelConnection,
        panBy: store.panBy,
        onConnect: onConnectExtended,
        onConnectStart: (event22, startParams) => {
          var _a;
          (_a = store.onconnectstart) == null ? void 0 : _a.call(store, event22, {
            nodeId: startParams.nodeId,
            handleId: startParams.handleId,
            handleType: startParams.handleType
          });
        },
        onConnectEnd: (event22, connectionState) => {
          var _a;
          (_a = store.onconnectend) == null ? void 0 : _a.call(store, event22, connectionState);
        },
        getTransform: () => [
          store.viewport.x,
          store.viewport.y,
          store.viewport.zoom
        ],
        getFromHandle: () => store.connection.fromHandle,
        dragThreshold: store.connectionDragThreshold
      });
    }
  }
  function onclick2(event2) {
    var _a, _b;
    if (!nodeId || !store.clickConnectStartHandle && !isConnectableStart()) {
      return;
    }
    if (!store.clickConnectStartHandle) {
      (_a = store.onclickconnectstart) == null ? void 0 : _a.call(store, event2, {
        nodeId,
        handleId: handleId(),
        handleType: type()
      });
      store.clickConnectStartHandle = { nodeId, type: type(), id: handleId() };
      return;
    }
    const doc = getHostForElement(event2.target);
    const isValidConnectionHandler = $$props.isValidConnection ?? store.isValidConnection;
    const {
      connectionMode,
      clickConnectStartHandle,
      flowId,
      nodeLookup
    } = store;
    const { connection, isValid } = XYHandle.isValid(event2, {
      handle: { nodeId, id: handleId(), type: type() },
      connectionMode,
      fromNodeId: clickConnectStartHandle.nodeId,
      fromHandleId: clickConnectStartHandle.id ?? null,
      fromType: clickConnectStartHandle.type,
      isValidConnection: isValidConnectionHandler,
      flowId,
      doc,
      lib: "svelte",
      nodeLookup
    });
    if (isValid && connection) {
      onConnectExtended(connection);
    }
    const connectionClone = structuredClone(snapshot(store.connection));
    delete connectionClone.inProgress;
    connectionClone.toPosition = connectionClone.toHandle ? connectionClone.toHandle.position : null;
    (_b = store.onclickconnectend) == null ? void 0 : _b.call(store, event2, connectionClone);
    store.clickConnectStartHandle = null;
  }
  var div = root();
  var event_handler = () => {
  };
  attribute_effect(
    div,
    ($0) => ({
      "data-handleid": handleId(),
      "data-nodeid": nodeId,
      "data-handlepos": position(),
      "data-id": `${store.flowId ?? ""}-${nodeId ?? ""}-${handleId() ?? "null" ?? ""}-${type() ?? ""}`,
      class: [
        "svelte-flow__handle",
        `svelte-flow__handle-${position()}`,
        store.noDragClass,
        store.noPanClass,
        position(),
        $$props.class
      ],
      onmousedown: onpointerdown,
      ontouchstart: onpointerdown,
      onclick: store.clickConnect ? onclick2 : void 0,
      onkeypress: event_handler,
      style: $$props.style,
      role: "button",
      "aria-label": get(ariaLabelConfig)[`handle.ariaLabel`],
      tabindex: "-1",
      ...rest,
      [CLASS]: $0
    }),
    [
      () => ({
        valid: get(valid),
        connectingto: get(connectingTo),
        connectingfrom: get(connectingFrom),
        source: !get(isTarget),
        target: get(isTarget),
        connectablestart: isConnectableStart(),
        connectableend: isConnectableEnd(),
        connectable: get(isConnectable),
        connectionindicator: get(isConnectable) && (!get(connectionInProgress) || get(isPossibleTargetHandle)) && (get(connectionInProgress) || store.clickConnectStartHandle ? isConnectableEnd() : isConnectableStart())
      })
    ]
  );
  var node = child(div);
  snippet(node, () => $$props.children ?? noop);
  reset(div);
  append($$anchor, div);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/components/nodes/DefaultNode.svelte
DefaultNode[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/nodes/DefaultNode.svelte";
var root2 = add_locations(from_html(`<!> <!>`, 1), DefaultNode[FILENAME], []);
function DefaultNode($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, DefaultNode);
  let targetPosition = prop($$props, "targetPosition", 19, () => Position.Top), sourcePosition = prop($$props, "sourcePosition", 19, () => Position.Bottom);
  var fragment = root2();
  var node = first_child(fragment);
  Handle(node, {
    type: "target",
    get position() {
      return targetPosition();
    }
  });
  var text2 = sibling(node);
  var node_1 = sibling(text2);
  Handle(node_1, {
    type: "source",
    get position() {
      return sourcePosition();
    }
  });
  template_effect(() => {
    var _a;
    return set_text(text2, ` ${((_a = $$props.data) == null ? void 0 : _a.label) ?? ""} `);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/components/nodes/InputNode.svelte
InputNode[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/nodes/InputNode.svelte";
var root3 = add_locations(from_html(` <!>`, 1), InputNode[FILENAME], []);
function InputNode($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, InputNode);
  let data = prop($$props, "data", 19, () => ({ label: "Node" })), sourcePosition = prop($$props, "sourcePosition", 19, () => Position.Bottom);
  next();
  var fragment = root3();
  var text2 = first_child(fragment);
  var node = sibling(text2);
  Handle(node, {
    type: "source",
    get position() {
      return sourcePosition();
    }
  });
  template_effect(() => {
    var _a;
    return set_text(text2, `${((_a = data()) == null ? void 0 : _a.label) ?? ""} `);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/components/nodes/OutputNode.svelte
OutputNode[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/nodes/OutputNode.svelte";
var root4 = add_locations(from_html(` <!>`, 1), OutputNode[FILENAME], []);
function OutputNode($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, OutputNode);
  let data = prop($$props, "data", 19, () => ({ label: "Node" })), targetPosition = prop($$props, "targetPosition", 19, () => Position.Top);
  next();
  var fragment = root4();
  var text2 = first_child(fragment);
  var node = sibling(text2);
  Handle(node, {
    type: "target",
    get position() {
      return targetPosition();
    }
  });
  template_effect(() => {
    var _a;
    return set_text(text2, `${((_a = data()) == null ? void 0 : _a.label) ?? ""} `);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/components/nodes/GroupNode.svelte
GroupNode[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/nodes/GroupNode.svelte";
function GroupNode($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, GroupNode);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/actions/portal/portal.svelte.js
function tryToMount(node, domNode, target) {
  if (!target || !domNode) {
    return;
  }
  const targetEl = target === "root" ? domNode : domNode.querySelector(`.svelte-flow__${target}`);
  if (targetEl) {
    targetEl.appendChild(node);
  }
}
function portal(node, target) {
  const $$d = user_derived(useStore), domNode = user_derived(() => get($$d).domNode);
  let destroyEffect;
  if (get(domNode)) {
    tryToMount(node, get(domNode), target);
  } else {
    destroyEffect = effect_root(() => {
      user_effect(() => {
        tryToMount(node, get(domNode), target);
        destroyEffect == null ? void 0 : destroyEffect();
      });
    });
  }
  return {
    async update(target2) {
      tryToMount(node, get(domNode), target2);
    },
    destroy() {
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      }
      destroyEffect == null ? void 0 : destroyEffect();
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/actions/portal/utils.svelte.js
function hideOnSSR() {
  let hide = state(typeof window === "undefined");
  if (get(hide)) {
    const destroyEffect = effect_root(() => {
      user_effect(() => {
        set(hide, false);
        destroyEffect == null ? void 0 : destroyEffect();
      });
    });
  }
  return {
    get value() {
      return get(hide);
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/utils/index.js
var isNode = (element) => isNodeBase(element);
var isEdge = (element) => isEdgeBase(element);
function toPxString(value) {
  return value === void 0 ? void 0 : `${value}px`;
}
var arrowKeyDiffs = {
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 },
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 }
};

// node_modules/@xyflow/svelte/dist/lib/components/EdgeLabel/EdgeLabel.svelte
EdgeLabel[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/EdgeLabel/EdgeLabel.svelte";
var root5 = add_locations(from_html(`<div><!></div>`), EdgeLabel[FILENAME], [[23, 0]]);
var $$css = {
  hash: "svelte-w2n27y",
  code: "\r\n  .transparent.svelte-w2n27y {\r\n    background: transparent;\r\n  }\r\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRWRnZUxhYmVsLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFnRE87QUFDUCxFQUFFLDBCQUFZLENBQUM7QUFDZixJQUFJLHVCQUF1QjtBQUMzQixHQUFHIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJFZGdlTGFiZWwuc3ZlbHRlIl19 */"
};
function EdgeLabel($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, EdgeLabel);
  append_styles($$anchor, $$css);
  let x = prop($$props, "x", 3, 0), y = prop($$props, "y", 3, 0), selectEdgeOnClick = prop($$props, "selectEdgeOnClick", 3, false), transparent = prop($$props, "transparent", 3, false), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "x",
      "y",
      "width",
      "height",
      "selectEdgeOnClick",
      "transparent",
      "class",
      "children"
    ],
    "rest"
  );
  const store = useStore();
  const id = getContext("svelteflow__edge_id");
  let z = tag(
    user_derived(() => {
      var _a;
      return (_a = store.visible.edges.get(id)) == null ? void 0 : _a.zIndex;
    }),
    "z"
  );
  var div = root5();
  var event_handler = () => {
    if (selectEdgeOnClick() && id) store.handleEdgeSelection(id);
  };
  attribute_effect(
    div,
    ($0, $1, $2) => ({
      class: [
        "svelte-flow__edge-label",
        { transparent: transparent() },
        $$props.class
      ],
      tabindex: "-1",
      onclick: event_handler,
      ...rest,
      [STYLE]: {
        display: $0,
        cursor: selectEdgeOnClick() ? "pointer" : void 0,
        transform: `translate(-50%, -50%) translate(${x() ?? ""}px,${y() ?? ""}px)`,
        "pointer-events": "all",
        width: $1,
        height: $2,
        "z-index": get(z)
      }
    }),
    [
      () => hideOnSSR().value ? "none" : void 0,
      () => toPxString($$props.width),
      () => toPxString($$props.height)
    ],
    "svelte-w2n27y"
  );
  var node = child(div);
  snippet(node, () => $$props.children ?? noop);
  reset(div);
  action(div, ($$node, $$action_arg) => {
    var _a;
    return (_a = portal) == null ? void 0 : _a($$node, $$action_arg);
  }, () => "edge-labels");
  append($$anchor, div);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/components/edges/BaseEdge.svelte
BaseEdge[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/edges/BaseEdge.svelte";
var root_1 = add_locations(from_svg(`<path></path>`), BaseEdge[FILENAME], [[29, 2]]);
var root6 = add_locations(from_svg(`<path fill="none"></path><!><!>`, 1), BaseEdge[FILENAME], [[18, 0]]);
function BaseEdge($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, BaseEdge);
  let interactionWidth = prop($$props, "interactionWidth", 3, 20), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "id",
      "path",
      "label",
      "labelX",
      "labelY",
      "labelStyle",
      "markerStart",
      "markerEnd",
      "style",
      "interactionWidth",
      "class"
    ],
    "rest"
  );
  var fragment = root6();
  var path_1 = first_child(fragment);
  var node = sibling(path_1);
  {
    var consequent = ($$anchor2) => {
      var path_2 = root_1();
      attribute_effect(path_2, () => ({
        d: $$props.path,
        "stroke-opacity": 0,
        "stroke-width": interactionWidth(),
        fill: "none",
        class: "svelte-flow__edge-interaction",
        ...rest
      }));
      append($$anchor2, path_2);
    };
    if_block(node, ($$render) => {
      if (interactionWidth() > 0) $$render(consequent);
    });
  }
  var node_1 = sibling(node);
  {
    var consequent_1 = ($$anchor2) => {
      EdgeLabel($$anchor2, {
        get x() {
          return $$props.labelX;
        },
        get y() {
          return $$props.labelY;
        },
        get style() {
          return $$props.labelStyle;
        },
        selectEdgeOnClick: true,
        children: wrap_snippet(BaseEdge, ($$anchor3, $$slotProps) => {
          next();
          var text2 = text();
          template_effect(() => set_text(text2, $$props.label));
          append($$anchor3, text2);
        }),
        $$slots: { default: true }
      });
    };
    if_block(node_1, ($$render) => {
      if ($$props.label) $$render(consequent_1);
    });
  }
  template_effect(() => {
    set_attribute(path_1, "id", $$props.id);
    set_attribute(path_1, "d", $$props.path);
    set_class(path_1, 0, clsx(["svelte-flow__edge-path", $$props.class]));
    set_attribute(path_1, "marker-start", $$props.markerStart);
    set_attribute(path_1, "marker-end", $$props.markerEnd);
    set_style(path_1, $$props.style);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/components/edges/BezierEdge.svelte
BezierEdge[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/edges/BezierEdge.svelte";
function BezierEdge($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, BezierEdge);
  let $$d = tag(
    user_derived(() => {
      var _a;
      return getBezierPath({
        sourceX: $$props.sourceX,
        sourceY: $$props.sourceY,
        targetX: $$props.targetX,
        targetY: $$props.targetY,
        sourcePosition: $$props.sourcePosition,
        targetPosition: $$props.targetPosition,
        curvature: (_a = $$props.pathOptions) == null ? void 0 : _a.curvature
      });
    }),
    "[$derived iterable]"
  ), $$array = tag(user_derived(() => to_array(get($$d), 3)), "[$derived iterable]"), path = tag(user_derived(() => get($$array)[0]), "path"), labelX = tag(user_derived(() => get($$array)[1]), "labelX"), labelY = tag(user_derived(() => get($$array)[2]), "labelY");
  BaseEdge($$anchor, {
    get id() {
      return $$props.id;
    },
    get path() {
      return get(path);
    },
    get labelX() {
      return get(labelX);
    },
    get labelY() {
      return get(labelY);
    },
    get label() {
      return $$props.label;
    },
    get labelStyle() {
      return $$props.labelStyle;
    },
    get markerStart() {
      return $$props.markerStart;
    },
    get markerEnd() {
      return $$props.markerEnd;
    },
    get interactionWidth() {
      return $$props.interactionWidth;
    },
    get style() {
      return $$props.style;
    }
  });
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/components/edges/SmoothStepEdge.svelte
SmoothStepEdge[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/edges/SmoothStepEdge.svelte";
function SmoothStepEdge($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, SmoothStepEdge);
  let $$d = tag(
    user_derived(() => {
      var _a, _b, _c;
      return getSmoothStepPath({
        sourceX: $$props.sourceX,
        sourceY: $$props.sourceY,
        targetX: $$props.targetX,
        targetY: $$props.targetY,
        sourcePosition: $$props.sourcePosition,
        targetPosition: $$props.targetPosition,
        borderRadius: (_a = $$props.pathOptions) == null ? void 0 : _a.borderRadius,
        offset: (_b = $$props.pathOptions) == null ? void 0 : _b.offset,
        stepPosition: (_c = $$props.pathOptions) == null ? void 0 : _c.stepPosition
      });
    }),
    "[$derived iterable]"
  ), $$array = tag(user_derived(() => to_array(get($$d), 3)), "[$derived iterable]"), path = tag(user_derived(() => get($$array)[0]), "path"), labelX = tag(user_derived(() => get($$array)[1]), "labelX"), labelY = tag(user_derived(() => get($$array)[2]), "labelY");
  BaseEdge($$anchor, {
    get id() {
      return $$props.id;
    },
    get path() {
      return get(path);
    },
    get labelX() {
      return get(labelX);
    },
    get labelY() {
      return get(labelY);
    },
    get label() {
      return $$props.label;
    },
    get labelStyle() {
      return $$props.labelStyle;
    },
    get markerStart() {
      return $$props.markerStart;
    },
    get markerEnd() {
      return $$props.markerEnd;
    },
    get interactionWidth() {
      return $$props.interactionWidth;
    },
    get style() {
      return $$props.style;
    }
  });
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/components/edges/SmoothStepEdgeInternal.svelte
SmoothStepEdgeInternal[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/edges/SmoothStepEdgeInternal.svelte";
function SmoothStepEdgeInternal($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, SmoothStepEdgeInternal);
  let $$d = tag(
    user_derived(() => getSmoothStepPath({
      sourceX: $$props.sourceX,
      sourceY: $$props.sourceY,
      targetX: $$props.targetX,
      targetY: $$props.targetY,
      sourcePosition: $$props.sourcePosition,
      targetPosition: $$props.targetPosition
    })),
    "[$derived iterable]"
  ), $$array = tag(user_derived(() => to_array(get($$d), 3)), "[$derived iterable]"), path = tag(user_derived(() => get($$array)[0]), "path"), labelX = tag(user_derived(() => get($$array)[1]), "labelX"), labelY = tag(user_derived(() => get($$array)[2]), "labelY");
  BaseEdge($$anchor, {
    get path() {
      return get(path);
    },
    get labelX() {
      return get(labelX);
    },
    get labelY() {
      return get(labelY);
    },
    get label() {
      return $$props.label;
    },
    get labelStyle() {
      return $$props.labelStyle;
    },
    get markerStart() {
      return $$props.markerStart;
    },
    get markerEnd() {
      return $$props.markerEnd;
    },
    get interactionWidth() {
      return $$props.interactionWidth;
    },
    get style() {
      return $$props.style;
    }
  });
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/components/edges/StraightEdge.svelte
StraightEdge[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/edges/StraightEdge.svelte";
function StraightEdge($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, StraightEdge);
  let $$d = tag(
    user_derived(() => getStraightPath({
      sourceX: $$props.sourceX,
      sourceY: $$props.sourceY,
      targetX: $$props.targetX,
      targetY: $$props.targetY
    })),
    "[$derived iterable]"
  ), $$array = tag(user_derived(() => to_array(get($$d), 3)), "[$derived iterable]"), path = tag(user_derived(() => get($$array)[0]), "path"), labelX = tag(user_derived(() => get($$array)[1]), "labelX"), labelY = tag(user_derived(() => get($$array)[2]), "labelY");
  BaseEdge($$anchor, {
    get id() {
      return $$props.id;
    },
    get path() {
      return get(path);
    },
    get labelX() {
      return get(labelX);
    },
    get labelY() {
      return get(labelY);
    },
    get label() {
      return $$props.label;
    },
    get labelStyle() {
      return $$props.labelStyle;
    },
    get markerStart() {
      return $$props.markerStart;
    },
    get markerEnd() {
      return $$props.markerEnd;
    },
    get interactionWidth() {
      return $$props.interactionWidth;
    },
    get style() {
      return $$props.style;
    }
  });
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/components/edges/StraightEdgeInternal.svelte
StraightEdgeInternal[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/edges/StraightEdgeInternal.svelte";
function StraightEdgeInternal($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, StraightEdgeInternal);
  let $$d = tag(
    user_derived(() => getStraightPath({
      sourceX: $$props.sourceX,
      sourceY: $$props.sourceY,
      targetX: $$props.targetX,
      targetY: $$props.targetY
    })),
    "[$derived iterable]"
  ), $$array = tag(user_derived(() => to_array(get($$d), 3)), "[$derived iterable]"), path = tag(user_derived(() => get($$array)[0]), "path"), labelX = tag(user_derived(() => get($$array)[1]), "labelX"), labelY = tag(user_derived(() => get($$array)[2]), "labelY");
  BaseEdge($$anchor, {
    get path() {
      return get(path);
    },
    get labelX() {
      return get(labelX);
    },
    get labelY() {
      return get(labelY);
    },
    get label() {
      return $$props.label;
    },
    get labelStyle() {
      return $$props.labelStyle;
    },
    get markerStart() {
      return $$props.markerStart;
    },
    get markerEnd() {
      return $$props.markerEnd;
    },
    get interactionWidth() {
      return $$props.interactionWidth;
    },
    get style() {
      return $$props.style;
    }
  });
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/components/edges/StepEdge.svelte
StepEdge[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/edges/StepEdge.svelte";
function StepEdge($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, StepEdge);
  let $$d = tag(
    user_derived(() => {
      var _a;
      return getSmoothStepPath({
        sourceX: $$props.sourceX,
        sourceY: $$props.sourceY,
        targetX: $$props.targetX,
        targetY: $$props.targetY,
        sourcePosition: $$props.sourcePosition,
        targetPosition: $$props.targetPosition,
        borderRadius: 0,
        offset: (_a = $$props.pathOptions) == null ? void 0 : _a.offset
      });
    }),
    "[$derived iterable]"
  ), $$array = tag(user_derived(() => to_array(get($$d), 3)), "[$derived iterable]"), path = tag(user_derived(() => get($$array)[0]), "path"), labelX = tag(user_derived(() => get($$array)[1]), "labelX"), labelY = tag(user_derived(() => get($$array)[2]), "labelY");
  BaseEdge($$anchor, {
    get id() {
      return $$props.id;
    },
    get path() {
      return get(path);
    },
    get labelX() {
      return get(labelX);
    },
    get labelY() {
      return get(labelY);
    },
    get label() {
      return $$props.label;
    },
    get labelStyle() {
      return $$props.labelStyle;
    },
    get markerStart() {
      return $$props.markerStart;
    },
    get markerEnd() {
      return $$props.markerEnd;
    },
    get interactionWidth() {
      return $$props.interactionWidth;
    },
    get style() {
      return $$props.style;
    }
  });
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/components/edges/StepEdgeInternal.svelte
StepEdgeInternal[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/edges/StepEdgeInternal.svelte";
function StepEdgeInternal($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, StepEdgeInternal);
  let $$d = tag(
    user_derived(() => getSmoothStepPath({
      sourceX: $$props.sourceX,
      sourceY: $$props.sourceY,
      targetX: $$props.targetX,
      targetY: $$props.targetY,
      sourcePosition: $$props.sourcePosition,
      targetPosition: $$props.targetPosition,
      borderRadius: 0
    })),
    "[$derived iterable]"
  ), $$array = tag(user_derived(() => to_array(get($$d), 3)), "[$derived iterable]"), path = tag(user_derived(() => get($$array)[0]), "path"), labelX = tag(user_derived(() => get($$array)[1]), "labelX"), labelY = tag(user_derived(() => get($$array)[2]), "labelY");
  BaseEdge($$anchor, {
    get path() {
      return get(path);
    },
    get labelX() {
      return get(labelX);
    },
    get labelY() {
      return get(labelY);
    },
    get label() {
      return $$props.label;
    },
    get labelStyle() {
      return $$props.labelStyle;
    },
    get markerStart() {
      return $$props.markerStart;
    },
    get markerEnd() {
      return $$props.markerEnd;
    },
    get interactionWidth() {
      return $$props.interactionWidth;
    },
    get style() {
      return $$props.style;
    }
  });
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/store/visibleElements.js
function getVisibleNodes(nodeLookup, transform, width, height) {
  const visibleNodes = /* @__PURE__ */ new Map();
  getNodesInside(nodeLookup, { x: 0, y: 0, width, height }, transform, true).forEach((node) => {
    visibleNodes.set(node.id, node);
  });
  return visibleNodes;
}
function getLayoutedEdges(options) {
  const { edges, defaultEdgeOptions, nodeLookup, previousEdges, connectionMode, onerror, onlyRenderVisible, elevateEdgesOnSelect } = options;
  const layoutedEdges = /* @__PURE__ */ new Map();
  for (const edge of edges) {
    const sourceNode = nodeLookup.get(edge.source);
    const targetNode = nodeLookup.get(edge.target);
    if (!sourceNode || !targetNode) {
      continue;
    }
    if (onlyRenderVisible) {
      const { visibleNodes, transform, width, height } = options;
      if (isEdgeVisible({
        sourceNode,
        targetNode,
        width,
        height,
        transform
      })) {
        visibleNodes.set(sourceNode.id, sourceNode);
        visibleNodes.set(targetNode.id, targetNode);
      } else {
        continue;
      }
    }
    const previous = previousEdges.get(edge.id);
    if (previous && edge === previous.edge && sourceNode == previous.sourceNode && targetNode == previous.targetNode) {
      layoutedEdges.set(edge.id, previous);
      continue;
    }
    const edgePosition = getEdgePosition({
      id: edge.id,
      sourceNode,
      targetNode,
      sourceHandle: edge.sourceHandle || null,
      targetHandle: edge.targetHandle || null,
      connectionMode,
      onError: onerror
    });
    if (edgePosition) {
      layoutedEdges.set(edge.id, {
        ...defaultEdgeOptions,
        ...edge,
        ...edgePosition,
        zIndex: getElevatedEdgeZIndex({
          selected: edge.selected,
          zIndex: edge.zIndex ?? defaultEdgeOptions.zIndex,
          sourceNode,
          targetNode,
          elevateOnSelect: elevateEdgesOnSelect
        }),
        sourceNode,
        targetNode,
        edge
      });
    }
  }
  return layoutedEdges;
}

// node_modules/@xyflow/svelte/dist/lib/store/initial-store.svelte.js
var initialNodeTypes = {
  input: InputNode,
  output: OutputNode,
  default: DefaultNode,
  group: GroupNode
};
var initialEdgeTypes = {
  straight: StraightEdgeInternal,
  smoothstep: SmoothStepEdgeInternal,
  default: BezierEdge,
  step: StepEdgeInternal
};
function getInitialViewport(_nodesInitialized, fitView, initialViewport, width, height, nodeLookup) {
  if (fitView && !initialViewport && width && height) {
    const bounds = getInternalNodesBounds(nodeLookup, {
      filter: (node) => !!((node.width || node.initialWidth) && (node.height || node.initialHeight))
    });
    return getViewportForBounds(bounds, width, height, 0.5, 2, 0.1);
  } else {
    return initialViewport ?? { x: 0, y: 0, zoom: 1 };
  }
}
function getInitialStore(signals) {
  var _flowId, _domNode, _panZoom, _width, _height, _nodesInitialized, _viewportInitialized, __edges, _selectedNodes, _selectedEdges, _visible, _nodesDraggable, _nodesConnectable, _elementsSelectable, _nodesFocusable, _edgesFocusable, _disableKeyboardA11y, _minZoom, _maxZoom, _nodeOrigin, _nodeExtent, _translateExtent, _defaultEdgeOptions, _nodeDragThreshold, _autoPanOnNodeDrag, _autoPanOnConnect, _autoPanOnNodeFocus, _connectionDragThreshold, _snapGrid, _dragging, _selectionRect, _selectionKeyPressed, _multiselectionKeyPressed, _deleteKeyPressed, _panActivationKeyPressed, _zoomActivationKeyPressed, _selectionRectMode, _ariaLiveMessage, _selectionMode, _nodeTypes, _edgeTypes, _noPanClass, _noDragClass, _noWheelClass, _ariaLabelConfig, __viewport, __connection, _connection, _connectionMode, _connectionRadius, _isValidConnection, _selectNodesOnDrag, _defaultMarkerColor, _markers, _onlyRenderVisibleElements, _onerror, _ondelete, _onbeforedelete, _onbeforeconnect, _onconnect, _onconnectstart, _onconnectend, _onbeforereconnect, _onreconnect, _onreconnectstart, _onreconnectend, _clickConnect, _onclickconnectstart, _onclickconnectend, _clickConnectStartHandle, _onselectiondrag, _onselectiondragstart, _onselectiondragstop, _colorMode;
  class SvelteFlowStore {
    constructor() {
      __privateAdd(this, _flowId, user_derived(() => signals.props.id ?? "1"));
      __privateAdd(this, _domNode, state(null));
      __privateAdd(this, _panZoom, state(null));
      __privateAdd(this, _width, state(signals.width ?? 0));
      __privateAdd(this, _height, state(signals.height ?? 0));
      __privateAdd(this, _nodesInitialized, user_derived(() => {
        var _a;
        const nodesInitialized = adoptUserNodes(signals.nodes, this.nodeLookup, this.parentLookup, {
          nodeExtent: this.nodeExtent,
          nodeOrigin: this.nodeOrigin,
          elevateNodesOnSelect: signals.props.elevateNodesOnSelect ?? true,
          checkEquality: true
        });
        if (this.fitViewQueued && nodesInitialized) {
          if ((_a = this.fitViewOptions) == null ? void 0 : _a.duration) {
            this.resolveFitView();
          } else {
            queueMicrotask(() => {
              this.resolveFitView();
            });
          }
        }
        return nodesInitialized;
      }));
      __privateAdd(this, _viewportInitialized, user_derived(() => this.panZoom !== null));
      __privateAdd(this, __edges, user_derived(() => {
        updateConnectionLookup(this.connectionLookup, this.edgeLookup, signals.edges);
        return signals.edges;
      }));
      __publicField(this, "_prevSelectedNodes", []);
      __publicField(this, "_prevSelectedNodeIds", /* @__PURE__ */ new Set());
      __privateAdd(this, _selectedNodes, user_derived(() => {
        const selectedNodesCount = this._prevSelectedNodeIds.size;
        const selectedNodeIds = /* @__PURE__ */ new Set();
        const selectedNodes = this.nodes.filter((node) => {
          if (node.selected) {
            selectedNodeIds.add(node.id);
            this._prevSelectedNodeIds.delete(node.id);
          }
          return node.selected;
        });
        if (selectedNodesCount !== selectedNodeIds.size || this._prevSelectedNodeIds.size > 0) {
          this._prevSelectedNodes = selectedNodes;
        }
        this._prevSelectedNodeIds = selectedNodeIds;
        return this._prevSelectedNodes;
      }));
      __publicField(this, "_prevSelectedEdges", []);
      __publicField(this, "_prevSelectedEdgeIds", /* @__PURE__ */ new Set());
      __privateAdd(this, _selectedEdges, user_derived(() => {
        const selectedEdgesCount = this._prevSelectedEdgeIds.size;
        const selectedEdgeIds = /* @__PURE__ */ new Set();
        const selectedEdges = this.edges.filter((edge) => {
          if (edge.selected) {
            selectedEdgeIds.add(edge.id);
            this._prevSelectedEdgeIds.delete(edge.id);
          }
          return edge.selected;
        });
        if (selectedEdgesCount !== selectedEdgeIds.size || this._prevSelectedEdgeIds.size > 0) {
          this._prevSelectedEdges = selectedEdges;
        }
        this._prevSelectedEdgeIds = selectedEdgeIds;
        return this._prevSelectedEdges;
      }));
      __publicField(this, "selectionChangeHandlers", /* @__PURE__ */ new Map());
      __publicField(this, "nodeLookup", /* @__PURE__ */ new Map());
      __publicField(this, "parentLookup", /* @__PURE__ */ new Map());
      __publicField(this, "connectionLookup", /* @__PURE__ */ new Map());
      __publicField(this, "edgeLookup", /* @__PURE__ */ new Map());
      __publicField(this, "_prevVisibleEdges", /* @__PURE__ */ new Map());
      __privateAdd(this, _visible, user_derived(() => {
        const {
          // We need to access this._nodes to trigger on changes
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          nodes,
          _edges: edges,
          _prevVisibleEdges: previousEdges,
          nodeLookup,
          connectionMode,
          onerror,
          onlyRenderVisibleElements,
          defaultEdgeOptions
        } = this;
        let visibleNodes;
        let visibleEdges;
        const options = {
          edges,
          defaultEdgeOptions,
          previousEdges,
          nodeLookup,
          connectionMode,
          elevateEdgesOnSelect: signals.props.elevateEdgesOnSelect ?? true,
          onerror
        };
        if (onlyRenderVisibleElements) {
          const { viewport, width, height } = this;
          const transform = [viewport.x, viewport.y, viewport.zoom];
          visibleNodes = getVisibleNodes(nodeLookup, transform, width, height);
          visibleEdges = getLayoutedEdges({
            ...options,
            onlyRenderVisible: true,
            visibleNodes,
            transform,
            width,
            height
          });
        } else {
          visibleNodes = this.nodeLookup;
          visibleEdges = getLayoutedEdges(options);
        }
        return { nodes: visibleNodes, edges: visibleEdges };
      }));
      __privateAdd(this, _nodesDraggable, user_derived(() => signals.props.nodesDraggable ?? true));
      __privateAdd(this, _nodesConnectable, user_derived(() => signals.props.nodesConnectable ?? true));
      __privateAdd(this, _elementsSelectable, user_derived(() => signals.props.elementsSelectable ?? true));
      __privateAdd(this, _nodesFocusable, user_derived(() => signals.props.nodesFocusable ?? true));
      __privateAdd(this, _edgesFocusable, user_derived(() => signals.props.edgesFocusable ?? true));
      __privateAdd(this, _disableKeyboardA11y, user_derived(() => signals.props.disableKeyboardA11y ?? false));
      __privateAdd(this, _minZoom, user_derived(() => signals.props.minZoom ?? 0.5));
      __privateAdd(this, _maxZoom, user_derived(() => signals.props.maxZoom ?? 2));
      __privateAdd(this, _nodeOrigin, user_derived(() => signals.props.nodeOrigin ?? [0, 0]));
      __privateAdd(this, _nodeExtent, user_derived(() => signals.props.nodeExtent ?? infiniteExtent));
      __privateAdd(this, _translateExtent, user_derived(() => signals.props.translateExtent ?? infiniteExtent));
      __privateAdd(this, _defaultEdgeOptions, user_derived(() => signals.props.defaultEdgeOptions ?? {}));
      __privateAdd(this, _nodeDragThreshold, user_derived(() => signals.props.nodeDragThreshold ?? 1));
      __privateAdd(this, _autoPanOnNodeDrag, user_derived(() => signals.props.autoPanOnNodeDrag ?? true));
      __privateAdd(this, _autoPanOnConnect, user_derived(() => signals.props.autoPanOnConnect ?? true));
      __privateAdd(this, _autoPanOnNodeFocus, user_derived(() => signals.props.autoPanOnNodeFocus ?? true));
      __privateAdd(this, _connectionDragThreshold, user_derived(() => signals.props.connectionDragThreshold ?? 1));
      __publicField(this, "fitViewQueued", signals.props.fitView ?? false);
      __publicField(this, "fitViewOptions", signals.props.fitViewOptions);
      __publicField(this, "fitViewResolver", null);
      __privateAdd(this, _snapGrid, user_derived(() => signals.props.snapGrid ?? null));
      __privateAdd(this, _dragging, state(false));
      __privateAdd(this, _selectionRect, state(null));
      __privateAdd(this, _selectionKeyPressed, state(false));
      __privateAdd(this, _multiselectionKeyPressed, state(false));
      __privateAdd(this, _deleteKeyPressed, state(false));
      __privateAdd(this, _panActivationKeyPressed, state(false));
      __privateAdd(this, _zoomActivationKeyPressed, state(false));
      __privateAdd(this, _selectionRectMode, state(null));
      __privateAdd(this, _ariaLiveMessage, state(""));
      __privateAdd(this, _selectionMode, user_derived(() => signals.props.selectionMode ?? SelectionMode.Partial));
      __privateAdd(this, _nodeTypes, user_derived(() => ({
        ...initialNodeTypes,
        ...signals.props.nodeTypes
      })));
      __privateAdd(this, _edgeTypes, user_derived(() => ({
        ...initialEdgeTypes,
        ...signals.props.edgeTypes
      })));
      __privateAdd(this, _noPanClass, user_derived(() => signals.props.noPanClass ?? "nopan"));
      __privateAdd(this, _noDragClass, user_derived(() => signals.props.noDragClass ?? "nodrag"));
      __privateAdd(this, _noWheelClass, user_derived(() => signals.props.noWheelClass ?? "nowheel"));
      __privateAdd(this, _ariaLabelConfig, user_derived(() => mergeAriaLabelConfig(signals.props.ariaLabelConfig)));
      __privateAdd(this, __viewport, state(getInitialViewport(this.nodesInitialized, signals.props.fitView, signals.props.initialViewport, this.width, this.height, this.nodeLookup)));
      __privateAdd(this, __connection, state(initialConnection));
      __privateAdd(this, _connection, user_derived(() => {
        if (!this._connection.inProgress) {
          return this._connection;
        }
        return {
          ...this._connection,
          to: pointToRendererPoint(this._connection.to, [
            this.viewport.x,
            this.viewport.y,
            this.viewport.zoom
          ])
        };
      }));
      __privateAdd(this, _connectionMode, user_derived(() => signals.props.connectionMode ?? ConnectionMode.Strict));
      __privateAdd(this, _connectionRadius, user_derived(() => signals.props.connectionRadius ?? 20));
      __privateAdd(this, _isValidConnection, user_derived(() => signals.props.isValidConnection ?? (() => true)));
      __privateAdd(this, _selectNodesOnDrag, user_derived(() => signals.props.selectNodesOnDrag ?? true));
      __privateAdd(this, _defaultMarkerColor, user_derived(() => signals.props.defaultMarkerColor ?? "#b1b1b7"));
      __privateAdd(this, _markers, user_derived(() => {
        return createMarkerIds(signals.edges, {
          defaultColor: this.defaultMarkerColor,
          id: this.flowId,
          defaultMarkerStart: this.defaultEdgeOptions.markerStart,
          defaultMarkerEnd: this.defaultEdgeOptions.markerEnd
        });
      }));
      __privateAdd(this, _onlyRenderVisibleElements, user_derived(() => signals.props.onlyRenderVisibleElements ?? false));
      __privateAdd(this, _onerror, user_derived(() => signals.props.onflowerror ?? devWarn));
      __privateAdd(this, _ondelete, user_derived(() => signals.props.ondelete));
      __privateAdd(this, _onbeforedelete, user_derived(() => signals.props.onbeforedelete));
      __privateAdd(this, _onbeforeconnect, user_derived(() => signals.props.onbeforeconnect));
      __privateAdd(this, _onconnect, user_derived(() => signals.props.onconnect));
      __privateAdd(this, _onconnectstart, user_derived(() => signals.props.onconnectstart));
      __privateAdd(this, _onconnectend, user_derived(() => signals.props.onconnectend));
      __privateAdd(this, _onbeforereconnect, user_derived(() => signals.props.onbeforereconnect));
      __privateAdd(this, _onreconnect, user_derived(() => signals.props.onreconnect));
      __privateAdd(this, _onreconnectstart, user_derived(() => signals.props.onreconnectstart));
      __privateAdd(this, _onreconnectend, user_derived(() => signals.props.onreconnectend));
      __privateAdd(this, _clickConnect, user_derived(() => signals.props.clickConnect ?? true));
      __privateAdd(this, _onclickconnectstart, user_derived(() => signals.props.onclickconnectstart));
      __privateAdd(this, _onclickconnectend, user_derived(() => signals.props.onclickconnectend));
      __privateAdd(this, _clickConnectStartHandle, state(null));
      __privateAdd(this, _onselectiondrag, user_derived(() => signals.props.onselectiondrag));
      __privateAdd(this, _onselectiondragstart, user_derived(() => signals.props.onselectiondragstart));
      __privateAdd(this, _onselectiondragstop, user_derived(() => signals.props.onselectiondragstop));
      __publicField(this, "resolveFitView", async () => {
        var _a;
        if (!this.panZoom) {
          return;
        }
        await fitViewport(
          {
            nodes: this.nodeLookup,
            width: this.width,
            height: this.height,
            panZoom: this.panZoom,
            minZoom: this.minZoom,
            maxZoom: this.maxZoom
          },
          this.fitViewOptions
        );
        (_a = this.fitViewResolver) == null ? void 0 : _a.resolve(true);
        this.fitViewQueued = false;
        this.fitViewOptions = void 0;
        this.fitViewResolver = null;
      });
      __publicField(this, "_prefersDark", new MediaQuery("(prefers-color-scheme: dark)", signals.props.colorModeSSR === "dark"));
      __privateAdd(this, _colorMode, user_derived(() => signals.props.colorMode === "system" ? this._prefersDark.current ? "dark" : "light" : signals.props.colorMode ?? "light"));
      if (true) {
        warnIfDeeplyReactive(signals.nodes, "nodes");
        warnIfDeeplyReactive(signals.edges, "edges");
      }
    }
    get flowId() {
      return get(__privateGet(this, _flowId));
    }
    set flowId(value) {
      set(__privateGet(this, _flowId), value);
    }
    get domNode() {
      return get(__privateGet(this, _domNode));
    }
    set domNode(value) {
      set(__privateGet(this, _domNode), value);
    }
    get panZoom() {
      return get(__privateGet(this, _panZoom));
    }
    set panZoom(value) {
      set(__privateGet(this, _panZoom), value);
    }
    get width() {
      return get(__privateGet(this, _width));
    }
    set width(value) {
      set(__privateGet(this, _width), value);
    }
    get height() {
      return get(__privateGet(this, _height));
    }
    set height(value) {
      set(__privateGet(this, _height), value);
    }
    get nodesInitialized() {
      return get(__privateGet(this, _nodesInitialized));
    }
    set nodesInitialized(value) {
      set(__privateGet(this, _nodesInitialized), value);
    }
    get viewportInitialized() {
      return get(__privateGet(this, _viewportInitialized));
    }
    set viewportInitialized(value) {
      set(__privateGet(this, _viewportInitialized), value);
    }
    get _edges() {
      return get(__privateGet(this, __edges));
    }
    set _edges(value) {
      set(__privateGet(this, __edges), value);
    }
    get nodes() {
      this.nodesInitialized;
      return signals.nodes;
    }
    set nodes(nodes) {
      signals.nodes = nodes;
    }
    get edges() {
      return this._edges;
    }
    set edges(edges) {
      signals.edges = edges;
    }
    get selectedNodes() {
      return get(__privateGet(this, _selectedNodes));
    }
    set selectedNodes(value) {
      set(__privateGet(this, _selectedNodes), value);
    }
    get selectedEdges() {
      return get(__privateGet(this, _selectedEdges));
    }
    set selectedEdges(value) {
      set(__privateGet(this, _selectedEdges), value);
    }
    get visible() {
      return get(__privateGet(this, _visible));
    }
    set visible(value) {
      set(__privateGet(this, _visible), value);
    }
    get nodesDraggable() {
      return get(__privateGet(this, _nodesDraggable));
    }
    set nodesDraggable(value) {
      set(__privateGet(this, _nodesDraggable), value);
    }
    get nodesConnectable() {
      return get(__privateGet(this, _nodesConnectable));
    }
    set nodesConnectable(value) {
      set(__privateGet(this, _nodesConnectable), value);
    }
    get elementsSelectable() {
      return get(__privateGet(this, _elementsSelectable));
    }
    set elementsSelectable(value) {
      set(__privateGet(this, _elementsSelectable), value);
    }
    get nodesFocusable() {
      return get(__privateGet(this, _nodesFocusable));
    }
    set nodesFocusable(value) {
      set(__privateGet(this, _nodesFocusable), value);
    }
    get edgesFocusable() {
      return get(__privateGet(this, _edgesFocusable));
    }
    set edgesFocusable(value) {
      set(__privateGet(this, _edgesFocusable), value);
    }
    get disableKeyboardA11y() {
      return get(__privateGet(this, _disableKeyboardA11y));
    }
    set disableKeyboardA11y(value) {
      set(__privateGet(this, _disableKeyboardA11y), value);
    }
    get minZoom() {
      return get(__privateGet(this, _minZoom));
    }
    set minZoom(value) {
      set(__privateGet(this, _minZoom), value);
    }
    get maxZoom() {
      return get(__privateGet(this, _maxZoom));
    }
    set maxZoom(value) {
      set(__privateGet(this, _maxZoom), value);
    }
    get nodeOrigin() {
      return get(__privateGet(this, _nodeOrigin));
    }
    set nodeOrigin(value) {
      set(__privateGet(this, _nodeOrigin), value);
    }
    get nodeExtent() {
      return get(__privateGet(this, _nodeExtent));
    }
    set nodeExtent(value) {
      set(__privateGet(this, _nodeExtent), value);
    }
    get translateExtent() {
      return get(__privateGet(this, _translateExtent));
    }
    set translateExtent(value) {
      set(__privateGet(this, _translateExtent), value);
    }
    get defaultEdgeOptions() {
      return get(__privateGet(this, _defaultEdgeOptions));
    }
    set defaultEdgeOptions(value) {
      set(__privateGet(this, _defaultEdgeOptions), value);
    }
    get nodeDragThreshold() {
      return get(__privateGet(this, _nodeDragThreshold));
    }
    set nodeDragThreshold(value) {
      set(__privateGet(this, _nodeDragThreshold), value);
    }
    get autoPanOnNodeDrag() {
      return get(__privateGet(this, _autoPanOnNodeDrag));
    }
    set autoPanOnNodeDrag(value) {
      set(__privateGet(this, _autoPanOnNodeDrag), value);
    }
    get autoPanOnConnect() {
      return get(__privateGet(this, _autoPanOnConnect));
    }
    set autoPanOnConnect(value) {
      set(__privateGet(this, _autoPanOnConnect), value);
    }
    get autoPanOnNodeFocus() {
      return get(__privateGet(this, _autoPanOnNodeFocus));
    }
    set autoPanOnNodeFocus(value) {
      set(__privateGet(this, _autoPanOnNodeFocus), value);
    }
    get connectionDragThreshold() {
      return get(__privateGet(this, _connectionDragThreshold));
    }
    set connectionDragThreshold(value) {
      set(__privateGet(this, _connectionDragThreshold), value);
    }
    get snapGrid() {
      return get(__privateGet(this, _snapGrid));
    }
    set snapGrid(value) {
      set(__privateGet(this, _snapGrid), value);
    }
    get dragging() {
      return get(__privateGet(this, _dragging));
    }
    set dragging(value) {
      set(__privateGet(this, _dragging), value);
    }
    get selectionRect() {
      return get(__privateGet(this, _selectionRect));
    }
    set selectionRect(value) {
      set(__privateGet(this, _selectionRect), value);
    }
    get selectionKeyPressed() {
      return get(__privateGet(this, _selectionKeyPressed));
    }
    set selectionKeyPressed(value) {
      set(__privateGet(this, _selectionKeyPressed), value);
    }
    get multiselectionKeyPressed() {
      return get(__privateGet(this, _multiselectionKeyPressed));
    }
    set multiselectionKeyPressed(value) {
      set(__privateGet(this, _multiselectionKeyPressed), value);
    }
    get deleteKeyPressed() {
      return get(__privateGet(this, _deleteKeyPressed));
    }
    set deleteKeyPressed(value) {
      set(__privateGet(this, _deleteKeyPressed), value);
    }
    get panActivationKeyPressed() {
      return get(__privateGet(this, _panActivationKeyPressed));
    }
    set panActivationKeyPressed(value) {
      set(__privateGet(this, _panActivationKeyPressed), value);
    }
    get zoomActivationKeyPressed() {
      return get(__privateGet(this, _zoomActivationKeyPressed));
    }
    set zoomActivationKeyPressed(value) {
      set(__privateGet(this, _zoomActivationKeyPressed), value);
    }
    get selectionRectMode() {
      return get(__privateGet(this, _selectionRectMode));
    }
    set selectionRectMode(value) {
      set(__privateGet(this, _selectionRectMode), value);
    }
    get ariaLiveMessage() {
      return get(__privateGet(this, _ariaLiveMessage));
    }
    set ariaLiveMessage(value) {
      set(__privateGet(this, _ariaLiveMessage), value);
    }
    get selectionMode() {
      return get(__privateGet(this, _selectionMode));
    }
    set selectionMode(value) {
      set(__privateGet(this, _selectionMode), value);
    }
    get nodeTypes() {
      return get(__privateGet(this, _nodeTypes));
    }
    set nodeTypes(value) {
      set(__privateGet(this, _nodeTypes), value);
    }
    get edgeTypes() {
      return get(__privateGet(this, _edgeTypes));
    }
    set edgeTypes(value) {
      set(__privateGet(this, _edgeTypes), value);
    }
    get noPanClass() {
      return get(__privateGet(this, _noPanClass));
    }
    set noPanClass(value) {
      set(__privateGet(this, _noPanClass), value);
    }
    get noDragClass() {
      return get(__privateGet(this, _noDragClass));
    }
    set noDragClass(value) {
      set(__privateGet(this, _noDragClass), value);
    }
    get noWheelClass() {
      return get(__privateGet(this, _noWheelClass));
    }
    set noWheelClass(value) {
      set(__privateGet(this, _noWheelClass), value);
    }
    get ariaLabelConfig() {
      return get(__privateGet(this, _ariaLabelConfig));
    }
    set ariaLabelConfig(value) {
      set(__privateGet(this, _ariaLabelConfig), value);
    }
    get _viewport() {
      return get(__privateGet(this, __viewport));
    }
    set _viewport(value) {
      set(__privateGet(this, __viewport), value);
    }
    get viewport() {
      return signals.viewport ?? this._viewport;
    }
    set viewport(newViewport) {
      if (signals.viewport) {
        signals.viewport = newViewport;
      }
      this._viewport = newViewport;
    }
    get _connection() {
      return get(__privateGet(this, __connection));
    }
    set _connection(value) {
      set(__privateGet(this, __connection), value);
    }
    get connection() {
      return get(__privateGet(this, _connection));
    }
    set connection(value) {
      set(__privateGet(this, _connection), value);
    }
    get connectionMode() {
      return get(__privateGet(this, _connectionMode));
    }
    set connectionMode(value) {
      set(__privateGet(this, _connectionMode), value);
    }
    get connectionRadius() {
      return get(__privateGet(this, _connectionRadius));
    }
    set connectionRadius(value) {
      set(__privateGet(this, _connectionRadius), value);
    }
    get isValidConnection() {
      return get(__privateGet(this, _isValidConnection));
    }
    set isValidConnection(value) {
      set(__privateGet(this, _isValidConnection), value);
    }
    get selectNodesOnDrag() {
      return get(__privateGet(this, _selectNodesOnDrag));
    }
    set selectNodesOnDrag(value) {
      set(__privateGet(this, _selectNodesOnDrag), value);
    }
    get defaultMarkerColor() {
      return get(__privateGet(this, _defaultMarkerColor));
    }
    set defaultMarkerColor(value) {
      set(__privateGet(this, _defaultMarkerColor), value);
    }
    get markers() {
      return get(__privateGet(this, _markers));
    }
    set markers(value) {
      set(__privateGet(this, _markers), value);
    }
    get onlyRenderVisibleElements() {
      return get(__privateGet(this, _onlyRenderVisibleElements));
    }
    set onlyRenderVisibleElements(value) {
      set(__privateGet(this, _onlyRenderVisibleElements), value);
    }
    get onerror() {
      return get(__privateGet(this, _onerror));
    }
    set onerror(value) {
      set(__privateGet(this, _onerror), value);
    }
    get ondelete() {
      return get(__privateGet(this, _ondelete));
    }
    set ondelete(value) {
      set(__privateGet(this, _ondelete), value);
    }
    get onbeforedelete() {
      return get(__privateGet(this, _onbeforedelete));
    }
    set onbeforedelete(value) {
      set(__privateGet(this, _onbeforedelete), value);
    }
    get onbeforeconnect() {
      return get(__privateGet(this, _onbeforeconnect));
    }
    set onbeforeconnect(value) {
      set(__privateGet(this, _onbeforeconnect), value);
    }
    get onconnect() {
      return get(__privateGet(this, _onconnect));
    }
    set onconnect(value) {
      set(__privateGet(this, _onconnect), value);
    }
    get onconnectstart() {
      return get(__privateGet(this, _onconnectstart));
    }
    set onconnectstart(value) {
      set(__privateGet(this, _onconnectstart), value);
    }
    get onconnectend() {
      return get(__privateGet(this, _onconnectend));
    }
    set onconnectend(value) {
      set(__privateGet(this, _onconnectend), value);
    }
    get onbeforereconnect() {
      return get(__privateGet(this, _onbeforereconnect));
    }
    set onbeforereconnect(value) {
      set(__privateGet(this, _onbeforereconnect), value);
    }
    get onreconnect() {
      return get(__privateGet(this, _onreconnect));
    }
    set onreconnect(value) {
      set(__privateGet(this, _onreconnect), value);
    }
    get onreconnectstart() {
      return get(__privateGet(this, _onreconnectstart));
    }
    set onreconnectstart(value) {
      set(__privateGet(this, _onreconnectstart), value);
    }
    get onreconnectend() {
      return get(__privateGet(this, _onreconnectend));
    }
    set onreconnectend(value) {
      set(__privateGet(this, _onreconnectend), value);
    }
    get clickConnect() {
      return get(__privateGet(this, _clickConnect));
    }
    set clickConnect(value) {
      set(__privateGet(this, _clickConnect), value);
    }
    get onclickconnectstart() {
      return get(__privateGet(this, _onclickconnectstart));
    }
    set onclickconnectstart(value) {
      set(__privateGet(this, _onclickconnectstart), value);
    }
    get onclickconnectend() {
      return get(__privateGet(this, _onclickconnectend));
    }
    set onclickconnectend(value) {
      set(__privateGet(this, _onclickconnectend), value);
    }
    get clickConnectStartHandle() {
      return get(__privateGet(this, _clickConnectStartHandle));
    }
    set clickConnectStartHandle(value) {
      set(__privateGet(this, _clickConnectStartHandle), value);
    }
    get onselectiondrag() {
      return get(__privateGet(this, _onselectiondrag));
    }
    set onselectiondrag(value) {
      set(__privateGet(this, _onselectiondrag), value);
    }
    get onselectiondragstart() {
      return get(__privateGet(this, _onselectiondragstart));
    }
    set onselectiondragstart(value) {
      set(__privateGet(this, _onselectiondragstart), value);
    }
    get onselectiondragstop() {
      return get(__privateGet(this, _onselectiondragstop));
    }
    set onselectiondragstop(value) {
      set(__privateGet(this, _onselectiondragstop), value);
    }
    get colorMode() {
      return get(__privateGet(this, _colorMode));
    }
    set colorMode(value) {
      set(__privateGet(this, _colorMode), value);
    }
    resetStoreValues() {
      this.dragging = false;
      this.selectionRect = null;
      this.selectionRectMode = null;
      this.selectionKeyPressed = false;
      this.multiselectionKeyPressed = false;
      this.deleteKeyPressed = false;
      this.panActivationKeyPressed = false;
      this.zoomActivationKeyPressed = false;
      this._connection = initialConnection;
      this.clickConnectStartHandle = null;
      this.viewport = signals.props.initialViewport ?? { x: 0, y: 0, zoom: 1 };
      this.ariaLiveMessage = "";
    }
  }
  _flowId = new WeakMap();
  _domNode = new WeakMap();
  _panZoom = new WeakMap();
  _width = new WeakMap();
  _height = new WeakMap();
  _nodesInitialized = new WeakMap();
  _viewportInitialized = new WeakMap();
  __edges = new WeakMap();
  _selectedNodes = new WeakMap();
  _selectedEdges = new WeakMap();
  _visible = new WeakMap();
  _nodesDraggable = new WeakMap();
  _nodesConnectable = new WeakMap();
  _elementsSelectable = new WeakMap();
  _nodesFocusable = new WeakMap();
  _edgesFocusable = new WeakMap();
  _disableKeyboardA11y = new WeakMap();
  _minZoom = new WeakMap();
  _maxZoom = new WeakMap();
  _nodeOrigin = new WeakMap();
  _nodeExtent = new WeakMap();
  _translateExtent = new WeakMap();
  _defaultEdgeOptions = new WeakMap();
  _nodeDragThreshold = new WeakMap();
  _autoPanOnNodeDrag = new WeakMap();
  _autoPanOnConnect = new WeakMap();
  _autoPanOnNodeFocus = new WeakMap();
  _connectionDragThreshold = new WeakMap();
  _snapGrid = new WeakMap();
  _dragging = new WeakMap();
  _selectionRect = new WeakMap();
  _selectionKeyPressed = new WeakMap();
  _multiselectionKeyPressed = new WeakMap();
  _deleteKeyPressed = new WeakMap();
  _panActivationKeyPressed = new WeakMap();
  _zoomActivationKeyPressed = new WeakMap();
  _selectionRectMode = new WeakMap();
  _ariaLiveMessage = new WeakMap();
  _selectionMode = new WeakMap();
  _nodeTypes = new WeakMap();
  _edgeTypes = new WeakMap();
  _noPanClass = new WeakMap();
  _noDragClass = new WeakMap();
  _noWheelClass = new WeakMap();
  _ariaLabelConfig = new WeakMap();
  __viewport = new WeakMap();
  __connection = new WeakMap();
  _connection = new WeakMap();
  _connectionMode = new WeakMap();
  _connectionRadius = new WeakMap();
  _isValidConnection = new WeakMap();
  _selectNodesOnDrag = new WeakMap();
  _defaultMarkerColor = new WeakMap();
  _markers = new WeakMap();
  _onlyRenderVisibleElements = new WeakMap();
  _onerror = new WeakMap();
  _ondelete = new WeakMap();
  _onbeforedelete = new WeakMap();
  _onbeforeconnect = new WeakMap();
  _onconnect = new WeakMap();
  _onconnectstart = new WeakMap();
  _onconnectend = new WeakMap();
  _onbeforereconnect = new WeakMap();
  _onreconnect = new WeakMap();
  _onreconnectstart = new WeakMap();
  _onreconnectend = new WeakMap();
  _clickConnect = new WeakMap();
  _onclickconnectstart = new WeakMap();
  _onclickconnectend = new WeakMap();
  _clickConnectStartHandle = new WeakMap();
  _onselectiondrag = new WeakMap();
  _onselectiondragstart = new WeakMap();
  _onselectiondragstop = new WeakMap();
  _colorMode = new WeakMap();
  return new SvelteFlowStore();
}
function warnIfDeeplyReactive(array, name) {
  try {
    if (array && array.length > 0) {
      structuredClone(array[0]);
    }
  } catch {
    console.warn(`Use $state.raw for ${name} to prevent performance issues.`);
  }
}

// node_modules/@xyflow/svelte/dist/lib/hooks/derivedWarning.svelte.js
function derivedWarning(functionName) {
  const storeContext = getContext(key);
  if (!storeContext) {
    throw new Error(`In order to use ${functionName}() you need to wrap your component in a <SvelteFlowProvider />`);
  }
  if (storeContext.provider && typeof window === "object" && !effect_tracking()) {
    throw new Error(`Use $derived(${functionName}()) to receive updates when values change.`);
  }
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useStore.js
function useStore() {
  const storeContext = getContext(key);
  if (!storeContext) {
    throw new Error("To call useStore outside of <SvelteFlow /> you need to wrap your component in a <SvelteFlowProvider />");
  }
  if (true) {
    derivedWarning("useStore");
  }
  return storeContext.getStore();
}

// node_modules/@xyflow/svelte/dist/lib/store/index.js
var key = Symbol();
function createStore(signals) {
  const store = getInitialStore(signals);
  function setNodeTypes(nodeTypes) {
    store.nodeTypes = {
      ...initialNodeTypes,
      ...nodeTypes
    };
  }
  function setEdgeTypes(edgeTypes) {
    store.edgeTypes = {
      ...initialEdgeTypes,
      ...edgeTypes
    };
  }
  function addEdge2(edgeParams) {
    store.edges = addEdge(edgeParams, store.edges);
  }
  const updateNodePositions = (nodeDragItems, dragging = false) => {
    store.nodes = store.nodes.map((node) => {
      const dragItem = nodeDragItems.get(node.id);
      return dragItem ? { ...node, position: dragItem.position, dragging } : node;
    });
  };
  function updateNodeInternals2(updates) {
    var _a, _b, _c;
    const { changes, updatedInternals } = updateNodeInternals(updates, store.nodeLookup, store.parentLookup, store.domNode, store.nodeOrigin);
    if (!updatedInternals) {
      return;
    }
    updateAbsolutePositions(store.nodeLookup, store.parentLookup, {
      nodeOrigin: store.nodeOrigin,
      nodeExtent: store.nodeExtent
    });
    if (store.fitViewQueued) {
      store.resolveFitView();
    }
    const newNodes = /* @__PURE__ */ new Map();
    for (const change of changes) {
      const userNode = (_a = store.nodeLookup.get(change.id)) == null ? void 0 : _a.internals.userNode;
      if (!userNode) {
        continue;
      }
      const node = { ...userNode };
      switch (change.type) {
        case "dimensions": {
          const measured = { ...node.measured, ...change.dimensions };
          if (change.setAttributes) {
            node.width = ((_b = change.dimensions) == null ? void 0 : _b.width) ?? node.width;
            node.height = ((_c = change.dimensions) == null ? void 0 : _c.height) ?? node.height;
          }
          node.measured = measured;
          break;
        }
        case "position":
          node.position = change.position ?? node.position;
          break;
      }
      newNodes.set(change.id, node);
    }
    store.nodes = store.nodes.map((node) => newNodes.get(node.id) ?? node);
  }
  function fitView(options) {
    const fitViewResolver = store.fitViewResolver ?? Promise.withResolvers();
    store.fitViewQueued = true;
    store.fitViewOptions = options;
    store.fitViewResolver = fitViewResolver;
    store.nodes = [...store.nodes];
    return fitViewResolver.promise;
  }
  async function setCenter(x, y, options) {
    const nextZoom = typeof (options == null ? void 0 : options.zoom) !== "undefined" ? options.zoom : store.maxZoom;
    const currentPanZoom = store.panZoom;
    if (!currentPanZoom) {
      return Promise.resolve(false);
    }
    await currentPanZoom.setViewport({
      x: store.width / 2 - x * nextZoom,
      y: store.height / 2 - y * nextZoom,
      zoom: nextZoom
    }, { duration: options == null ? void 0 : options.duration, ease: options == null ? void 0 : options.ease, interpolate: options == null ? void 0 : options.interpolate });
    return Promise.resolve(true);
  }
  function zoomBy(factor, options) {
    const panZoom = store.panZoom;
    if (!panZoom) {
      return Promise.resolve(false);
    }
    return panZoom.scaleBy(factor, options);
  }
  function zoomIn(options) {
    return zoomBy(1.2, options);
  }
  function zoomOut(options) {
    return zoomBy(1 / 1.2, options);
  }
  function setMinZoom(minZoom) {
    const panZoom = store.panZoom;
    if (panZoom) {
      panZoom.setScaleExtent([minZoom, store.maxZoom]);
      store.minZoom = minZoom;
    }
  }
  function setMaxZoom(maxZoom) {
    const panZoom = store.panZoom;
    if (panZoom) {
      panZoom.setScaleExtent([store.minZoom, maxZoom]);
      store.maxZoom = maxZoom;
    }
  }
  function setTranslateExtent(extent) {
    const panZoom = store.panZoom;
    if (panZoom) {
      panZoom.setTranslateExtent(extent);
      store.translateExtent = extent;
    }
  }
  function setPaneClickDistance(distance) {
    var _a;
    (_a = store.panZoom) == null ? void 0 : _a.setClickDistance(distance);
  }
  function deselect(elements, elementsToDeselect = null) {
    let deselected = false;
    const newElements = elements.map((element) => {
      const shouldDeselect = elementsToDeselect ? elementsToDeselect.has(element.id) : true;
      if (shouldDeselect && element.selected) {
        deselected = true;
        return { ...element, selected: false };
      }
      return element;
    });
    return [deselected, newElements];
  }
  function unselectNodesAndEdges(params) {
    const nodesToDeselect = (params == null ? void 0 : params.nodes) ? new Set(params.nodes.map((node) => node.id)) : null;
    const [nodesDeselected, newNodes] = deselect(store.nodes, nodesToDeselect);
    if (nodesDeselected) {
      store.nodes = newNodes;
    }
    const edgesToDeselect = (params == null ? void 0 : params.edges) ? new Set(params.edges.map((node) => node.id)) : null;
    const [edgesDeselected, newEdges] = deselect(store.edges, edgesToDeselect);
    if (edgesDeselected) {
      store.edges = newEdges;
    }
  }
  function addSelectedNodes(ids) {
    const isMultiSelection = store.multiselectionKeyPressed;
    store.nodes = store.nodes.map((node) => {
      const nodeWillBeSelected = ids.includes(node.id);
      const selected = isMultiSelection ? node.selected || nodeWillBeSelected : nodeWillBeSelected;
      if (node.selected !== selected) {
        const internalNode = store.nodeLookup.get(node.id);
        if (internalNode)
          internalNode.selected = selected;
        node.selected = selected;
        return { ...node };
      }
      return node;
    });
    if (!isMultiSelection) {
      unselectNodesAndEdges({ nodes: [] });
    }
  }
  function addSelectedEdges(ids) {
    const isMultiSelection = store.multiselectionKeyPressed;
    store.edges = store.edges.map((edge) => {
      const edgeWillBeSelected = ids.includes(edge.id);
      const selected = isMultiSelection ? edge.selected || edgeWillBeSelected : edgeWillBeSelected;
      if (edge.selected !== selected) {
        return { ...edge, selected };
      }
      return edge;
    });
    if (!isMultiSelection) {
      unselectNodesAndEdges({ edges: [] });
    }
  }
  function handleNodeSelection(id, unselect, nodeRef) {
    const node = store.nodeLookup.get(id);
    if (!node) {
      console.warn("012", errorMessages["error012"](id));
      return;
    }
    store.selectionRect = null;
    store.selectionRectMode = null;
    if (!node.selected) {
      addSelectedNodes([id]);
    } else if (unselect || node.selected && store.multiselectionKeyPressed) {
      unselectNodesAndEdges({ nodes: [node], edges: [] });
      requestAnimationFrame(() => nodeRef == null ? void 0 : nodeRef.blur());
    }
  }
  function handleEdgeSelection(id) {
    const edge = store.edgeLookup.get(id);
    if (!edge) {
      console.warn("012", errorMessages["error012"](id));
      return;
    }
    const selectable = edge.selectable || store.elementsSelectable && typeof edge.selectable === "undefined";
    if (selectable) {
      store.selectionRect = null;
      store.selectionRectMode = null;
      if (!edge.selected) {
        addSelectedEdges([id]);
      } else if (edge.selected && store.multiselectionKeyPressed) {
        unselectNodesAndEdges({ nodes: [], edges: [edge] });
      }
    }
  }
  function moveSelectedNodes(direction, factor) {
    const { nodeExtent, snapGrid, nodeOrigin, nodeLookup, nodesDraggable, onerror } = store;
    const nodeUpdates = /* @__PURE__ */ new Map();
    const xVelo = (snapGrid == null ? void 0 : snapGrid[0]) ?? 5;
    const yVelo = (snapGrid == null ? void 0 : snapGrid[1]) ?? 5;
    const xDiff = direction.x * xVelo * factor;
    const yDiff = direction.y * yVelo * factor;
    for (const node of nodeLookup.values()) {
      const isSelected = node.selected && (node.draggable || nodesDraggable && typeof node.draggable === "undefined");
      if (!isSelected) {
        continue;
      }
      let nextPosition = {
        x: node.internals.positionAbsolute.x + xDiff,
        y: node.internals.positionAbsolute.y + yDiff
      };
      if (snapGrid) {
        nextPosition = snapPosition(nextPosition, snapGrid);
      }
      const { position, positionAbsolute } = calculateNodePosition({
        nodeId: node.id,
        nextPosition,
        nodeLookup,
        nodeExtent,
        nodeOrigin,
        onError: onerror
      });
      node.position = position;
      node.internals.positionAbsolute = positionAbsolute;
      nodeUpdates.set(node.id, node);
    }
    updateNodePositions(nodeUpdates);
  }
  function panBy2(delta) {
    return panBy({
      delta,
      panZoom: store.panZoom,
      transform: [store.viewport.x, store.viewport.y, store.viewport.zoom],
      translateExtent: store.translateExtent,
      width: store.width,
      height: store.height
    });
  }
  const updateConnection = (newConnection) => {
    store._connection = { ...newConnection };
  };
  function cancelConnection() {
    store._connection = initialConnection;
  }
  function reset2() {
    store.resetStoreValues();
    unselectNodesAndEdges();
  }
  const storeWithActions = Object.assign(store, {
    setNodeTypes,
    setEdgeTypes,
    addEdge: addEdge2,
    updateNodePositions,
    updateNodeInternals: updateNodeInternals2,
    zoomIn,
    zoomOut,
    fitView,
    setCenter,
    setMinZoom,
    setMaxZoom,
    setTranslateExtent,
    setPaneClickDistance,
    unselectNodesAndEdges,
    addSelectedNodes,
    addSelectedEdges,
    handleNodeSelection,
    handleEdgeSelection,
    moveSelectedNodes,
    panBy: panBy2,
    updateConnection,
    cancelConnection,
    reset: reset2
  });
  return storeWithActions;
}

// node_modules/@xyflow/svelte/dist/lib/actions/zoom/index.js
function zoom(domNode, params) {
  const { minZoom, maxZoom, initialViewport, onPanZoomStart, onPanZoom, onPanZoomEnd, translateExtent, paneClickDistance, setPanZoomInstance, onDraggingChange, onTransformChange } = params;
  const panZoomInstance = XYPanZoom({
    domNode,
    minZoom,
    maxZoom,
    translateExtent,
    viewport: initialViewport,
    paneClickDistance,
    onPanZoom,
    onPanZoomStart,
    onPanZoomEnd,
    onDraggingChange
  });
  const viewport = panZoomInstance.getViewport();
  if (initialViewport.x !== viewport.x || initialViewport.y !== viewport.y || initialViewport.zoom !== viewport.zoom) {
    onTransformChange([viewport.x, viewport.y, viewport.zoom]);
  }
  setPanZoomInstance(panZoomInstance);
  panZoomInstance.update(params);
  return {
    update(params2) {
      panZoomInstance.update(params2);
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/container/Zoom/Zoom.svelte
Zoom[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/container/Zoom/Zoom.svelte";
var root7 = add_locations(from_html(`<div class="svelte-flow__zoom svelte-flow__container"><!></div>`), Zoom[FILENAME], [[31, 0]]);
function Zoom($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Zoom);
  var $$ownership_validator = create_ownership_validator($$props);
  let store = prop($$props, "store", 15), panOnScrollMode = prop($$props, "panOnScrollMode", 19, () => PanOnScrollMode.Free), preventScrolling = prop($$props, "preventScrolling", 3, true), zoomOnScroll = prop($$props, "zoomOnScroll", 3, true), zoomOnDoubleClick = prop($$props, "zoomOnDoubleClick", 3, true), zoomOnPinch = prop($$props, "zoomOnPinch", 3, true), panOnDrag = prop($$props, "panOnDrag", 3, true), panOnScroll = prop($$props, "panOnScroll", 3, false), paneClickDistance = prop($$props, "paneClickDistance", 3, 1);
  let panOnDragActive = tag(user_derived(() => store().panActivationKeyPressed || panOnDrag()), "panOnDragActive");
  let panOnScrollActive = tag(user_derived(() => store().panActivationKeyPressed || panOnScroll()), "panOnScrollActive");
  const { viewport: initialViewport } = store();
  let onInitCalled = false;
  user_effect(() => {
    var _a;
    if (!onInitCalled && store().viewportInitialized) {
      (_a = $$props.oninit) == null ? void 0 : _a.call($$props);
      onInitCalled = true;
    }
  });
  var div = root7();
  var node = child(div);
  snippet(node, () => $$props.children);
  reset(div);
  action(div, ($$node, $$action_arg) => {
    var _a;
    return (_a = zoom) == null ? void 0 : _a($$node, $$action_arg);
  }, () => ({
    viewport: store().viewport,
    minZoom: store().minZoom,
    maxZoom: store().maxZoom,
    initialViewport,
    onDraggingChange: (dragging) => {
      $$ownership_validator.mutation("store", ["store", "dragging"], store(store().dragging = dragging, true), 39, 6);
    },
    setPanZoomInstance: (instance) => {
      $$ownership_validator.mutation("store", ["store", "panZoom"], store(store().panZoom = instance, true), 42, 6);
    },
    onPanZoomStart: $$props.onmovestart,
    onPanZoom: $$props.onmove,
    onPanZoomEnd: $$props.onmoveend,
    zoomOnScroll: zoomOnScroll(),
    zoomOnDoubleClick: zoomOnDoubleClick(),
    zoomOnPinch: zoomOnPinch(),
    panOnScroll: get(panOnScrollActive),
    panOnDrag: get(panOnDragActive),
    panOnScrollSpeed: 0.5,
    panOnScrollMode: panOnScrollMode() || PanOnScrollMode.Free,
    zoomActivationKeyPressed: store().zoomActivationKeyPressed,
    preventScrolling: strict_equals(typeof preventScrolling(), "boolean") ? preventScrolling() : true,
    noPanClassName: store().noPanClass,
    noWheelClassName: store().noWheelClass,
    userSelectionActive: !!store().selectionRect,
    translateExtent: store().translateExtent,
    lib: "svelte",
    paneClickDistance: paneClickDistance(),
    onTransformChange: (transform) => {
      $$ownership_validator.mutation(
        "store",
        ["store", "viewport"],
        store(
          store().viewport = {
            x: transform[0],
            y: transform[1],
            zoom: transform[2]
          },
          true
        ),
        63,
        6
      );
    }
  }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/container/Pane/Pane.svelte
Pane[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/container/Pane/Pane.svelte";
function wrapHandler(handler, container) {
  return (event2) => {
    if (strict_equals(event2.target, container, false)) {
      return;
    }
    handler == null ? void 0 : handler(event2);
  };
}
function toggleSelected(ids) {
  return (item) => {
    const isSelected = ids.has(item.id);
    if (strict_equals(!!item.selected, isSelected, false)) {
      return { ...item, selected: isSelected };
    }
    return item;
  };
}
function isSetEqual(a, b) {
  if (strict_equals(a.size, b.size, false)) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
}
var root8 = add_locations(from_html(`<div><!></div>`), Pane[FILENAME], [[155, 0]]);
function Pane($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Pane);
  var $$ownership_validator = create_ownership_validator($$props);
  let store = prop($$props, "store", 15), panOnDrag = prop($$props, "panOnDrag", 3, true);
  let container;
  let containerBounds = null;
  let selectedNodeIds = /* @__PURE__ */ new Set();
  let selectedEdgeIds = /* @__PURE__ */ new Set();
  let panOnDragActive = tag(user_derived(() => store().panActivationKeyPressed || panOnDrag()), "panOnDragActive");
  let isSelecting = tag(user_derived(() => store().selectionKeyPressed || store().selectionRect || $$props.selectionOnDrag && strict_equals(get(panOnDragActive), true, false)), "isSelecting");
  let hasActiveSelection = tag(user_derived(() => store().elementsSelectable && (get(isSelecting) || strict_equals(store().selectionRectMode, "user"))), "hasActiveSelection");
  let selectionInProgress = false;
  function onClick(event2) {
    var _a;
    if (selectionInProgress || store().connection.inProgress) {
      selectionInProgress = false;
      return;
    }
    (_a = $$props.onpaneclick) == null ? void 0 : _a.call($$props, { event: event2 });
    store().unselectNodesAndEdges();
    $$ownership_validator.mutation("store", ["store", "selectionRectMode"], store(store().selectionRectMode = null, true), 61, 2);
  }
  function onPointerDown(event2) {
    var _a, _b, _c;
    containerBounds = container == null ? void 0 : container.getBoundingClientRect();
    if (!store().elementsSelectable || !get(isSelecting) || strict_equals(event2.button, 0, false) || strict_equals(event2.target, container, false) || !containerBounds) {
      return;
    }
    (_b = (_a = event2.target) == null ? void 0 : _a.setPointerCapture) == null ? void 0 : _b.call(_a, event2.pointerId);
    const { x, y } = getEventPosition(event2, containerBounds);
    store().unselectNodesAndEdges();
    $$ownership_validator.mutation(
      "store",
      ["store", "selectionRect"],
      store(
        store().selectionRect = {
          width: 0,
          height: 0,
          startX: x,
          startY: y,
          x,
          y
        },
        true
      ),
      71,
      2
    );
    (_c = $$props.onselectionstart) == null ? void 0 : _c.call($$props, event2);
  }
  function onPointerMove(event2) {
    if (!get(isSelecting) || !containerBounds || !store().selectionRect) {
      return;
    }
    selectionInProgress = true;
    const mousePos = getEventPosition(event2, containerBounds);
    const { startX = 0, startY = 0 } = store().selectionRect;
    const nextUserSelectRect = {
      ...store().selectionRect,
      x: mousePos.x < startX ? mousePos.x : startX,
      y: mousePos.y < startY ? mousePos.y : startY,
      width: Math.abs(mousePos.x - startX),
      height: Math.abs(mousePos.y - startY)
    };
    const prevSelectedNodeIds = selectedNodeIds;
    const prevSelectedEdgeIds = selectedEdgeIds;
    selectedNodeIds = new Set(getNodesInside(
      store().nodeLookup,
      nextUserSelectRect,
      [
        store().viewport.x,
        store().viewport.y,
        store().viewport.zoom
      ],
      strict_equals(store().selectionMode, SelectionMode.Partial),
      true
    ).map((n) => n.id));
    const edgesSelectable = store().defaultEdgeOptions.selectable ?? true;
    selectedEdgeIds = /* @__PURE__ */ new Set();
    for (const nodeId of selectedNodeIds) {
      const connections = store().connectionLookup.get(nodeId);
      if (!connections) continue;
      for (const { edgeId } of connections.values()) {
        const edge = store().edgeLookup.get(edgeId);
        if (edge && (edge.selectable ?? edgesSelectable)) {
          selectedEdgeIds.add(edgeId);
        }
      }
    }
    if (!isSetEqual(prevSelectedNodeIds, selectedNodeIds)) {
      $$ownership_validator.mutation("store", ["store", "nodes"], store(store().nodes = store().nodes.map(toggleSelected(selectedNodeIds)), true), 119, 4);
    }
    if (!isSetEqual(prevSelectedEdgeIds, selectedEdgeIds)) {
      $$ownership_validator.mutation("store", ["store", "edges"], store(store().edges = store().edges.map(toggleSelected(selectedEdgeIds)), true), 122, 4);
    }
    $$ownership_validator.mutation("store", ["store", "selectionRectMode"], store(store().selectionRectMode = "user", true), 124, 2);
    $$ownership_validator.mutation("store", ["store", "selectionRect"], store(store().selectionRect = nextUserSelectRect, true), 125, 2);
  }
  function onPointerUp(event2) {
    var _a, _b, _c;
    if (strict_equals(event2.button, 0, false)) {
      return;
    }
    (_b = (_a = event2.target) == null ? void 0 : _a.releasePointerCapture) == null ? void 0 : _b.call(_a, event2.pointerId);
    if (!get(isSelecting) && strict_equals(store().selectionRectMode, "user") && strict_equals(event2.target, container)) {
      onClick == null ? void 0 : onClick(event2);
    }
    $$ownership_validator.mutation("store", ["store", "selectionRect"], store(store().selectionRect = null, true), 135, 2);
    if (selectedNodeIds.size > 0) {
      $$ownership_validator.mutation("store", ["store", "selectionRectMode"], store(store().selectionRectMode = "nodes", true), 137, 4);
    }
    if (store().selectionKeyPressed) {
      selectionInProgress = false;
    }
    (_c = $$props.onselectionend) == null ? void 0 : _c.call($$props, event2);
  }
  const onContextMenu = (event2) => {
    var _a;
    if (Array.isArray(get(panOnDragActive)) && get(panOnDragActive).includes(2)) {
      event2.preventDefault();
      return;
    }
    (_a = $$props.onpanecontextmenu) == null ? void 0 : _a.call($$props, { event: event2 });
  };
  var div = root8();
  let classes;
  var event_handler = user_derived(() => get(hasActiveSelection) ? void 0 : wrapHandler(onClick, container));
  div.__click = function(...$$args) {
    apply(() => get(event_handler), this, $$args, Pane, [161, 11]);
  };
  div.__pointerdown = function(...$$args) {
    apply(() => get(hasActiveSelection) ? onPointerDown : void 0, this, $$args, Pane, [162, 17]);
  };
  div.__pointermove = function(...$$args) {
    apply(() => get(hasActiveSelection) ? onPointerMove : void 0, this, $$args, Pane, [163, 17]);
  };
  div.__pointerup = function(...$$args) {
    apply(() => get(hasActiveSelection) ? onPointerUp : void 0, this, $$args, Pane, [164, 15]);
  };
  var event_handler_1 = user_derived(() => wrapHandler(onContextMenu, container));
  div.__contextmenu = function(...$$args) {
    apply(() => get(event_handler_1), this, $$args, Pane, [165, 17], true);
  };
  var node = child(div);
  snippet(node, () => $$props.children);
  reset(div);
  bind_this(div, ($$value) => container = $$value, () => container);
  template_effect(($0) => classes = set_class(div, 1, "svelte-flow__pane svelte-flow__container", null, classes, $0), [
    () => ({
      draggable: strict_equals(panOnDrag(), true) || Array.isArray(panOnDrag()) && panOnDrag().includes(0),
      dragging: store().dragging,
      selection: get(isSelecting)
    })
  ]);
  append($$anchor, div);
  return pop({ ...legacy_api() });
}
delegate([
  "click",
  "pointerdown",
  "pointermove",
  "pointerup",
  "contextmenu"
]);

// node_modules/@xyflow/svelte/dist/lib/container/Viewport/Viewport.svelte
Viewport[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/container/Viewport/Viewport.svelte";
var root9 = add_locations(from_html(`<div class="svelte-flow__viewport xyflow__viewport svelte-flow__container"><!></div>`), Viewport[FILENAME], [[7, 0]]);
function Viewport($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Viewport);
  var div = root9();
  let styles;
  var node = child(div);
  snippet(node, () => $$props.children);
  reset(div);
  template_effect(() => styles = set_style(div, "", styles, {
    transform: `translate(${$$props.store.viewport.x ?? ""}px, ${$$props.store.viewport.y ?? ""}px) scale(${$$props.store.viewport.zoom ?? ""})`
  }));
  append($$anchor, div);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/actions/drag/index.js
function drag(domNode, params) {
  const { store, onDrag, onDragStart, onDragStop, onNodeMouseDown } = params;
  const dragInstance = XYDrag({
    onDrag,
    onDragStart,
    onDragStop,
    onNodeMouseDown,
    getStoreItems: () => {
      const { snapGrid, viewport } = store;
      return {
        nodes: store.nodes,
        nodeLookup: store.nodeLookup,
        edges: store.edges,
        nodeExtent: store.nodeExtent,
        snapGrid: snapGrid ? snapGrid : [0, 0],
        snapToGrid: !!snapGrid,
        nodeOrigin: store.nodeOrigin,
        multiSelectionActive: store.multiselectionKeyPressed,
        domNode: store.domNode,
        transform: [viewport.x, viewport.y, viewport.zoom],
        autoPanOnNodeDrag: store.autoPanOnNodeDrag,
        nodesDraggable: store.nodesDraggable,
        selectNodesOnDrag: store.selectNodesOnDrag,
        nodeDragThreshold: store.nodeDragThreshold,
        unselectNodesAndEdges: store.unselectNodesAndEdges,
        updateNodePositions: store.updateNodePositions,
        onSelectionDrag: store.onselectiondrag,
        onSelectionDragStart: store.onselectiondragstart,
        onSelectionDragStop: store.onselectiondragstop,
        panBy: store.panBy
      };
    }
  });
  function updateDrag(domNode2, params2) {
    if (params2.disabled) {
      dragInstance.destroy();
      return;
    }
    dragInstance.update({
      domNode: domNode2,
      noDragClassName: params2.noDragClass,
      handleSelector: params2.handleSelector,
      nodeId: params2.nodeId,
      isSelectable: params2.isSelectable,
      nodeClickDistance: params2.nodeClickDistance
    });
  }
  updateDrag(domNode, params);
  return {
    update(params2) {
      updateDrag(domNode, params2);
    },
    destroy() {
      dragInstance.destroy();
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/components/A11yDescriptions/A11yDescriptions.svelte
A11yDescriptions[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/A11yDescriptions/A11yDescriptions.svelte";
var root_12 = add_locations(from_html(`<div aria-live="assertive" aria-atomic="true" class="a11y-live-msg svelte-62ze0y"> </div>`), A11yDescriptions[FILENAME], [[15, 2]]);
var root10 = add_locations(from_html(`<div class="a11y-hidden svelte-62ze0y"> </div> <div class="a11y-hidden svelte-62ze0y"> </div> <!>`, 1), A11yDescriptions[FILENAME], [[5, 0], [10, 0]]);
var $$css2 = {
  hash: "svelte-62ze0y",
  code: "\r\n  .a11y-hidden.svelte-62ze0y {\r\n    display: none;\r\n  }\r\n\r\n  .a11y-live-msg.svelte-62ze0y {\r\n    position: absolute;\r\n    width: 1px;\r\n    height: 1px;\r\n    margin: -1px;\r\n    border: 0;\r\n    padding: 0;\r\n    overflow: hidden;\r\n    clip: rect(0px, 0px, 0px, 0px);\r\n    clip-path: inset(100%);\r\n  }\r\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQTExeURlc2NyaXB0aW9ucy5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBNEJPO0FBQ1AsRUFBRSwwQkFBWSxDQUFDO0FBQ2YsSUFBSSxhQUFhO0FBQ2pCLEdBQUc7QUFDSDtBQUNBLEVBQUUsNEJBQWMsQ0FBQztBQUNqQixJQUFJLGtCQUFrQjtBQUN0QixJQUFJLFVBQVU7QUFDZCxJQUFJLFdBQVc7QUFDZixJQUFJLFlBQVk7QUFDaEIsSUFBSSxTQUFTO0FBQ2IsSUFBSSxVQUFVO0FBQ2QsSUFBSSxnQkFBZ0I7QUFDcEIsSUFBSSw4QkFBOEI7QUFDbEMsSUFBSSxzQkFBc0I7QUFDMUIsR0FBRyIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiQTExeURlc2NyaXB0aW9ucy5zdmVsdGUiXX0= */"
};
function A11yDescriptions($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, A11yDescriptions);
  append_styles($$anchor, $$css2);
  var fragment = root10();
  var div = first_child(fragment);
  var text2 = child(div, true);
  reset(div);
  var div_1 = sibling(div, 2);
  var text_1 = child(div_1, true);
  reset(div_1);
  var node = sibling(div_1, 2);
  {
    var consequent = ($$anchor2) => {
      var div_2 = root_12();
      var text_2 = child(div_2, true);
      reset(div_2);
      template_effect(() => {
        set_attribute(div_2, "id", `${ARIA_LIVE_MESSAGE}-${$$props.store.flowId}`);
        set_text(text_2, $$props.store.ariaLiveMessage);
      });
      append($$anchor2, div_2);
    };
    if_block(node, ($$render) => {
      if (!$$props.store.disableKeyboardA11y) $$render(consequent);
    });
  }
  template_effect(() => {
    set_attribute(div, "id", `${ARIA_NODE_DESC_KEY}-${$$props.store.flowId}`);
    set_text(text2, $$props.store.disableKeyboardA11y ? $$props.store.ariaLabelConfig["node.a11yDescription.default"] : $$props.store.ariaLabelConfig["node.a11yDescription.keyboardDisabled"]);
    set_attribute(div_1, "id", `${ARIA_EDGE_DESC_KEY}-${$$props.store.flowId}`);
    set_text(text_1, $$props.store.ariaLabelConfig["edge.a11yDescription.default"]);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/components/A11yDescriptions/index.js
var ARIA_NODE_DESC_KEY = "svelte-flow__node-desc";
var ARIA_EDGE_DESC_KEY = "svelte-flow__edge-desc";
var ARIA_LIVE_MESSAGE = "svelte-flow__aria-live";

// node_modules/@xyflow/svelte/dist/lib/components/NodeWrapper/NodeWrapper.svelte
NodeWrapper[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/NodeWrapper/NodeWrapper.svelte";
var root_13 = add_locations(from_html(`<div><!></div>`), NodeWrapper[FILENAME], [[179, 2]]);
function NodeWrapper($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, NodeWrapper);
  var $$ownership_validator = create_ownership_validator($$props);
  let store = prop($$props, "store", 15);
  let data = tag(user_derived(() => fallback($$props.node.data, () => ({}), true)), "data"), selected = tag(user_derived(() => fallback($$props.node.selected, false)), "selected"), _draggable = tag(user_derived(() => $$props.node.draggable), "_draggable"), _selectable = tag(user_derived(() => $$props.node.selectable), "_selectable"), deletable = tag(user_derived(() => fallback($$props.node.deletable, true)), "deletable"), _connectable = tag(user_derived(() => $$props.node.connectable), "_connectable"), _focusable = tag(user_derived(() => $$props.node.focusable), "_focusable"), hidden = tag(user_derived(() => fallback($$props.node.hidden, false)), "hidden"), dragging = tag(user_derived(() => fallback($$props.node.dragging, false)), "dragging"), style = tag(user_derived(() => fallback($$props.node.style, "")), "style"), className = tag(user_derived(() => $$props.node.class), "className"), type = tag(user_derived(() => fallback($$props.node.type, "default")), "type"), parentId = tag(user_derived(() => $$props.node.parentId), "parentId"), sourcePosition = tag(user_derived(() => $$props.node.sourcePosition), "sourcePosition"), targetPosition = tag(user_derived(() => $$props.node.targetPosition), "targetPosition"), measuredWidth = tag(user_derived(() => fallback($$props.node.measured, () => ({ width: 0, height: 0 }), true).width), "measuredWidth"), measuredHeight = tag(user_derived(() => fallback($$props.node.measured, () => ({ width: 0, height: 0 }), true).height), "measuredHeight"), initialWidth = tag(user_derived(() => $$props.node.initialWidth), "initialWidth"), initialHeight = tag(user_derived(() => $$props.node.initialHeight), "initialHeight"), width = tag(user_derived(() => $$props.node.width), "width"), height = tag(user_derived(() => $$props.node.height), "height"), dragHandle = tag(user_derived(() => $$props.node.dragHandle), "dragHandle"), zIndex = tag(user_derived(() => fallback($$props.node.internals.z, 0)), "zIndex"), positionX = tag(user_derived(() => $$props.node.internals.positionAbsolute.x), "positionX"), positionY = tag(user_derived(() => $$props.node.internals.positionAbsolute.y), "positionY"), userNode = tag(user_derived(() => $$props.node.internals.userNode), "userNode");
  let { id } = $$props.node;
  let draggable = tag(user_derived(() => get(_draggable) ?? store().nodesDraggable), "draggable");
  let selectable = tag(user_derived(() => get(_selectable) ?? store().elementsSelectable), "selectable");
  let connectable = tag(user_derived(() => get(_connectable) ?? store().nodesConnectable), "connectable");
  let hasDimensions = tag(user_derived(() => nodeHasDimensions($$props.node)), "hasDimensions");
  let hasHandleBounds = tag(user_derived(() => !!$$props.node.internals.handleBounds), "hasHandleBounds");
  let isInitialized = tag(user_derived(() => get(hasDimensions) && get(hasHandleBounds)), "isInitialized");
  let focusable = tag(user_derived(() => get(_focusable) ?? store().nodesFocusable), "focusable");
  function isInParentLookup(id2) {
    return store().parentLookup.has(id2);
  }
  let isParent = tag(user_derived(() => isInParentLookup(id)), "isParent");
  let nodeRef = tag(state(null), "nodeRef");
  let prevNodeRef = null;
  let prevType = get(type);
  let prevSourcePosition = get(sourcePosition);
  let prevTargetPosition = get(targetPosition);
  let NodeComponent = tag(user_derived(() => store().nodeTypes[get(type)] ?? DefaultNode), "NodeComponent");
  let ariaLabelConfig = tag(user_derived(() => store().ariaLabelConfig), "ariaLabelConfig");
  let connectableContext = {
    get value() {
      return get(connectable);
    }
  };
  setContext("svelteflow__node_connectable", connectableContext);
  setContext("svelteflow__node_id", id);
  if (strict_equals("development", "development")) {
    user_effect(() => {
      const valid = !!store().nodeTypes[get(type)];
      if (!valid) {
        console.warn(...log_if_contains_state("warn", "003", errorMessages["error003"](get(type))));
      }
    });
  }
  let nodeStyle = tag(
    user_derived(() => {
      const w = strict_equals(get(measuredWidth), void 0) ? get(width) ?? get(initialWidth) : get(width);
      const h = strict_equals(get(measuredHeight), void 0) ? get(height) ?? get(initialHeight) : get(height);
      if (strict_equals(w, void 0) && strict_equals(h, void 0) && strict_equals(get(style), void 0)) {
        return void 0;
      }
      return `${get(style)};${w ? `width:${toPxString(w)};` : ""}${h ? `height:${toPxString(h)};` : ""}`;
    }),
    "nodeStyle"
  );
  user_effect(() => {
    const doUpdate = strict_equals(get(type), prevType, false) || strict_equals(get(sourcePosition), prevSourcePosition, false) || strict_equals(get(targetPosition), prevTargetPosition, false);
    if (doUpdate && strict_equals(get(nodeRef), null, false)) {
      requestAnimationFrame(() => {
        if (strict_equals(get(nodeRef), null, false)) {
          store().updateNodeInternals(/* @__PURE__ */ new Map([
            [
              id,
              {
                id,
                nodeElement: get(nodeRef),
                force: true
              }
            ]
          ]));
        }
      });
    }
    prevType = get(type);
    prevSourcePosition = get(sourcePosition);
    prevTargetPosition = get(targetPosition);
  });
  user_effect(() => {
    if ($$props.resizeObserver && (!get(isInitialized) || strict_equals(get(nodeRef), prevNodeRef, false))) {
      prevNodeRef && $$props.resizeObserver.unobserve(prevNodeRef);
      get(nodeRef) && $$props.resizeObserver.observe(get(nodeRef));
      prevNodeRef = get(nodeRef);
    }
  });
  onDestroy(() => {
    var _a;
    if (prevNodeRef) {
      (_a = $$props.resizeObserver) == null ? void 0 : _a.unobserve(prevNodeRef);
    }
  });
  function onSelectNodeHandler(event2) {
    var _a;
    if (get(selectable) && (!store().selectNodesOnDrag || !get(draggable) || store().nodeDragThreshold > 0)) {
      store().handleNodeSelection(id);
    }
    (_a = $$props.onnodeclick) == null ? void 0 : _a.call($$props, { node: get(userNode), event: event2 });
  }
  function onKeyDown(event2) {
    if (isInputDOMNode(event2) || store().disableKeyboardA11y) {
      return;
    }
    if (elementSelectionKeys.includes(event2.key) && get(selectable)) {
      const unselect = strict_equals(event2.key, "Escape");
      store().handleNodeSelection(id, unselect, get(nodeRef));
    } else if (get(draggable) && $$props.node.selected && Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event2.key)) {
      event2.preventDefault();
      $$ownership_validator.mutation(
        "store",
        ["store", "ariaLiveMessage"],
        store(
          store().ariaLiveMessage = get(ariaLabelConfig)["node.a11yDescription.ariaLiveMessage"]({
            direction: event2.key.replace("Arrow", "").toLowerCase(),
            x: ~~$$props.node.internals.positionAbsolute.x,
            y: ~~$$props.node.internals.positionAbsolute.y
          }),
          true
        ),
        149,
        4
      );
      store().moveSelectedNodes(arrowKeyDiffs[event2.key], event2.shiftKey ? 4 : 1);
    }
  }
  const onFocus = () => {
    var _a;
    if (store().disableKeyboardA11y || !store().autoPanOnNodeFocus || !((_a = get(nodeRef)) == null ? void 0 : _a.matches(":focus-visible"))) {
      return;
    }
    const { width: width2, height: height2, viewport } = store();
    const withinViewport = getNodesInside(/* @__PURE__ */ new Map([[id, $$props.node]]), { x: 0, y: 0, width: width2, height: height2 }, [viewport.x, viewport.y, viewport.zoom], true).length > 0;
    if (!withinViewport) {
      store().setCenter($$props.node.position.x + ($$props.node.measured.width ?? 0) / 2, $$props.node.position.y + ($$props.node.measured.height ?? 0) / 2, { zoom: viewport.zoom });
    }
  };
  var fragment = comment();
  var node_1 = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var div = root_13();
      attribute_effect(
        div,
        ($0) => ({
          "data-id": id,
          class: [
            "svelte-flow__node",
            `svelte-flow__node-${get(type)}`,
            get(className)
          ],
          style: get(nodeStyle),
          onclick: onSelectNodeHandler,
          onpointerenter: $$props.onnodepointerenter ? (event2) => $$props.onnodepointerenter({ node: get(userNode), event: event2 }) : void 0,
          onpointerleave: $$props.onnodepointerleave ? (event2) => $$props.onnodepointerleave({ node: get(userNode), event: event2 }) : void 0,
          onpointermove: $$props.onnodepointermove ? (event2) => $$props.onnodepointermove({ node: get(userNode), event: event2 }) : void 0,
          oncontextmenu: $$props.onnodecontextmenu ? (event2) => $$props.onnodecontextmenu({ node: get(userNode), event: event2 }) : void 0,
          onkeydown: get(focusable) ? onKeyDown : void 0,
          onfocus: get(focusable) ? onFocus : void 0,
          tabIndex: get(focusable) ? 0 : void 0,
          role: $$props.node.ariaRole ?? (get(focusable) ? "group" : void 0),
          "aria-roledescription": "node",
          "aria-describedby": store().disableKeyboardA11y ? void 0 : `${ARIA_NODE_DESC_KEY}-${store().flowId}`,
          ...$$props.node.domAttributes,
          [CLASS]: $0,
          [STYLE]: {
            "z-index": get(zIndex),
            transform: `translate(${get(positionX) ?? ""}px, ${get(positionY) ?? ""}px)`,
            visibility: get(hasDimensions) ? "visible" : "hidden"
          }
        }),
        [
          () => ({
            dragging: get(dragging),
            selected: get(selected),
            draggable: get(draggable),
            connectable: get(connectable),
            selectable: get(selectable),
            nopan: get(draggable),
            parent: get(isParent)
          })
        ]
      );
      var node_2 = child(div);
      component(node_2, () => get(NodeComponent), ($$anchor3, NodeComponent_1) => {
        NodeComponent_1($$anchor3, {
          get data() {
            return get(data);
          },
          get id() {
            return id;
          },
          get selected() {
            return get(selected);
          },
          get selectable() {
            return get(selectable);
          },
          get deletable() {
            return get(deletable);
          },
          get sourcePosition() {
            return get(sourcePosition);
          },
          get targetPosition() {
            return get(targetPosition);
          },
          get zIndex() {
            return get(zIndex);
          },
          get dragging() {
            return get(dragging);
          },
          get draggable() {
            return get(draggable);
          },
          get dragHandle() {
            return get(dragHandle);
          },
          get parentId() {
            return get(parentId);
          },
          get type() {
            return get(type);
          },
          get isConnectable() {
            return get(connectable);
          },
          get positionAbsoluteX() {
            return get(positionX);
          },
          get positionAbsoluteY() {
            return get(positionY);
          },
          get width() {
            return get(width);
          },
          get height() {
            return get(height);
          }
        });
      });
      reset(div);
      action(div, ($$node, $$action_arg) => {
        var _a;
        return (_a = drag) == null ? void 0 : _a($$node, $$action_arg);
      }, () => ({
        nodeId: id,
        isSelectable: get(selectable),
        disabled: !get(draggable),
        handleSelector: get(dragHandle),
        noDragClass: store().noDragClass,
        nodeClickDistance: $$props.nodeClickDistance,
        onNodeMouseDown: store().handleNodeSelection,
        onDrag: (event2, _, targetNode, nodes) => {
          var _a;
          (_a = $$props.onnodedrag) == null ? void 0 : _a.call($$props, { event: event2, targetNode, nodes });
        },
        onDragStart: (event2, _, targetNode, nodes) => {
          var _a;
          (_a = $$props.onnodedragstart) == null ? void 0 : _a.call($$props, { event: event2, targetNode, nodes });
        },
        onDragStop: (event2, _, targetNode, nodes) => {
          var _a;
          (_a = $$props.onnodedragstop) == null ? void 0 : _a.call($$props, { event: event2, targetNode, nodes });
        },
        store: store()
      }));
      bind_this(div, ($$value) => set(nodeRef, $$value), () => get(nodeRef));
      append($$anchor2, div);
    };
    if_block(node_1, ($$render) => {
      if (!get(hidden)) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/container/NodeRenderer/NodeRenderer.svelte
NodeRenderer[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/container/NodeRenderer/NodeRenderer.svelte";
var root11 = add_locations(from_html(`<div class="svelte-flow__nodes"></div>`), NodeRenderer[FILENAME], [[32, 0]]);
function NodeRenderer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, NodeRenderer);
  var $$ownership_validator = create_ownership_validator($$props);
  let store = prop($$props, "store", 15);
  const resizeObserver = strict_equals(typeof ResizeObserver, "undefined") ? null : new ResizeObserver((entries) => {
    const updates = /* @__PURE__ */ new Map();
    entries.forEach((entry) => {
      const id = entry.target.getAttribute("data-id");
      updates.set(id, { id, nodeElement: entry.target, force: true });
    });
    store().updateNodeInternals(updates);
  });
  onDestroy(() => {
    resizeObserver == null ? void 0 : resizeObserver.disconnect();
  });
  var div = root11();
  validate_each_keys(() => store().visible.nodes.values(), (node) => node.id);
  each(div, 21, () => store().visible.nodes.values(), (node) => node.id, ($$anchor2, node) => {
    {
      $$ownership_validator.binding("store", NodeWrapper, store);
      NodeWrapper($$anchor2, {
        get node() {
          return get(node);
        },
        get resizeObserver() {
          return resizeObserver;
        },
        get nodeClickDistance() {
          return $$props.nodeClickDistance;
        },
        get onnodeclick() {
          return $$props.onnodeclick;
        },
        get onnodepointerenter() {
          return $$props.onnodepointerenter;
        },
        get onnodepointermove() {
          return $$props.onnodepointermove;
        },
        get onnodepointerleave() {
          return $$props.onnodepointerleave;
        },
        get onnodedrag() {
          return $$props.onnodedrag;
        },
        get onnodedragstart() {
          return $$props.onnodedragstart;
        },
        get onnodedragstop() {
          return $$props.onnodedragstop;
        },
        get onnodecontextmenu() {
          return $$props.onnodecontextmenu;
        },
        get store() {
          return store();
        },
        set store($$value) {
          store($$value);
        }
      });
    }
  });
  reset(div);
  append($$anchor, div);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/components/EdgeWrapper/EdgeWrapper.svelte
EdgeWrapper[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/EdgeWrapper/EdgeWrapper.svelte";
var root_14 = add_locations(from_svg(`<svg class="svelte-flow__edge-wrapper"><g><!></g></svg>`), EdgeWrapper[FILENAME], [[83, 2, [[84, 4]]]]);
function EdgeWrapper($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, EdgeWrapper);
  let source = tag(user_derived(() => $$props.edge.source), "source"), target = tag(user_derived(() => $$props.edge.target), "target"), sourceX = tag(user_derived(() => $$props.edge.sourceX), "sourceX"), sourceY = tag(user_derived(() => $$props.edge.sourceY), "sourceY"), targetX = tag(user_derived(() => $$props.edge.targetX), "targetX"), targetY = tag(user_derived(() => $$props.edge.targetY), "targetY"), sourcePosition = tag(user_derived(() => $$props.edge.sourcePosition), "sourcePosition"), targetPosition = tag(user_derived(() => $$props.edge.targetPosition), "targetPosition"), animated = tag(user_derived(() => fallback($$props.edge.animated, false)), "animated"), selected = tag(user_derived(() => fallback($$props.edge.selected, false)), "selected"), label = tag(user_derived(() => $$props.edge.label), "label"), labelStyle = tag(user_derived(() => $$props.edge.labelStyle), "labelStyle"), data = tag(user_derived(() => fallback($$props.edge.data, () => ({}), true)), "data"), style = tag(user_derived(() => $$props.edge.style), "style"), interactionWidth = tag(user_derived(() => $$props.edge.interactionWidth), "interactionWidth"), type = tag(user_derived(() => fallback($$props.edge.type, "default")), "type"), sourceHandle = tag(user_derived(() => $$props.edge.sourceHandle), "sourceHandle"), targetHandle = tag(user_derived(() => $$props.edge.targetHandle), "targetHandle"), markerStart = tag(user_derived(() => $$props.edge.markerStart), "markerStart"), markerEnd = tag(user_derived(() => $$props.edge.markerEnd), "markerEnd"), _selectable = tag(user_derived(() => $$props.edge.selectable), "_selectable"), _focusable = tag(user_derived(() => $$props.edge.focusable), "_focusable"), deletable = tag(user_derived(() => fallback($$props.edge.deletable, true)), "deletable"), hidden = tag(user_derived(() => $$props.edge.hidden), "hidden"), zIndex = tag(user_derived(() => $$props.edge.zIndex), "zIndex"), className = tag(user_derived(() => $$props.edge.class), "className"), ariaLabel = tag(user_derived(() => $$props.edge.ariaLabel), "ariaLabel");
  let edgeRef = null;
  const { id } = $$props.edge;
  setContext("svelteflow__edge_id", id);
  let selectable = tag(user_derived(() => get(_selectable) ?? $$props.store.elementsSelectable), "selectable");
  let focusable = tag(user_derived(() => get(_focusable) ?? $$props.store.edgesFocusable), "focusable");
  let EdgeComponent = tag(user_derived(() => $$props.store.edgeTypes[get(type)] ?? BezierEdge), "EdgeComponent");
  let markerStartUrl = tag(user_derived(() => get(markerStart) ? `url('#${getMarkerId(get(markerStart), $$props.store.flowId)}')` : void 0), "markerStartUrl");
  let markerEndUrl = tag(user_derived(() => get(markerEnd) ? `url('#${getMarkerId(get(markerEnd), $$props.store.flowId)}')` : void 0), "markerEndUrl");
  function onclick2(event2) {
    var _a;
    const edge2 = $$props.store.edgeLookup.get(id);
    if (edge2) {
      if (get(selectable)) $$props.store.handleEdgeSelection(id);
      (_a = $$props.onedgeclick) == null ? void 0 : _a.call($$props, { event: event2, edge: edge2 });
    }
  }
  function onmouseevent(event2, callback) {
    const edge2 = $$props.store.edgeLookup.get(id);
    if (edge2) {
      callback({ event: event2, edge: edge2 });
    }
  }
  function onkeydown(event2) {
    if (!$$props.store.disableKeyboardA11y && elementSelectionKeys.includes(event2.key) && get(selectable)) {
      const { unselectNodesAndEdges, addSelectedEdges } = $$props.store;
      const unselect = strict_equals(event2.key, "Escape");
      if (unselect) {
        edgeRef == null ? void 0 : edgeRef.blur();
        unselectNodesAndEdges({ edges: [$$props.edge] });
      } else {
        addSelectedEdges([id]);
      }
    }
  }
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var svg = root_14();
      let styles;
      var g = child(svg);
      attribute_effect(
        g,
        ($0) => ({
          class: ["svelte-flow__edge", get(className)],
          "data-id": id,
          onclick: onclick2,
          oncontextmenu: $$props.onedgecontextmenu ? (e) => {
            onmouseevent(e, $$props.onedgecontextmenu);
          } : void 0,
          onpointerenter: $$props.onedgepointerenter ? (e) => {
            onmouseevent(e, $$props.onedgepointerenter);
          } : void 0,
          onpointerleave: $$props.onedgepointerleave ? (e) => {
            onmouseevent(e, $$props.onedgepointerleave);
          } : void 0,
          "aria-label": strict_equals(get(ariaLabel), null) ? void 0 : get(ariaLabel) ? get(ariaLabel) : `Edge from ${get(source)} to ${get(target)}`,
          "aria-describedby": get(focusable) ? `${ARIA_EDGE_DESC_KEY}-${$$props.store.flowId}` : void 0,
          role: $$props.edge.ariaRole ?? (get(focusable) ? "group" : "img"),
          "aria-roledescription": "edge",
          onkeydown: get(focusable) ? onkeydown : void 0,
          tabindex: get(focusable) ? 0 : void 0,
          ...$$props.edge.domAttributes,
          [CLASS]: $0
        }),
        [
          () => ({
            animated: get(animated),
            selected: get(selected),
            selectable: get(selectable)
          })
        ]
      );
      var node_1 = child(g);
      component(node_1, () => get(EdgeComponent), ($$anchor3, EdgeComponent_1) => {
        EdgeComponent_1($$anchor3, {
          get id() {
            return id;
          },
          get source() {
            return get(source);
          },
          get target() {
            return get(target);
          },
          get sourceX() {
            return get(sourceX);
          },
          get sourceY() {
            return get(sourceY);
          },
          get targetX() {
            return get(targetX);
          },
          get targetY() {
            return get(targetY);
          },
          get sourcePosition() {
            return get(sourcePosition);
          },
          get targetPosition() {
            return get(targetPosition);
          },
          get animated() {
            return get(animated);
          },
          get selected() {
            return get(selected);
          },
          get label() {
            return get(label);
          },
          get labelStyle() {
            return get(labelStyle);
          },
          get data() {
            return get(data);
          },
          get style() {
            return get(style);
          },
          get interactionWidth() {
            return get(interactionWidth);
          },
          get selectable() {
            return get(selectable);
          },
          get deletable() {
            return get(deletable);
          },
          get type() {
            return get(type);
          },
          get sourceHandleId() {
            return get(sourceHandle);
          },
          get targetHandleId() {
            return get(targetHandle);
          },
          get markerStart() {
            return get(markerStartUrl);
          },
          get markerEnd() {
            return get(markerEndUrl);
          }
        });
      });
      reset(g);
      bind_this(g, ($$value) => edgeRef = $$value, () => edgeRef);
      reset(svg);
      template_effect(() => styles = set_style(svg, "", styles, { "z-index": get(zIndex) }));
      append($$anchor2, svg);
    };
    if_block(node, ($$render) => {
      if (!get(hidden)) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/MarkerDefinition/MarkerDefinition.svelte
MarkerDefinition[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/MarkerDefinition/MarkerDefinition.svelte";
var root12 = add_locations(from_svg(`<defs></defs>`), MarkerDefinition[FILENAME], [[6, 0]]);
function MarkerDefinition($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, MarkerDefinition);
  const store = useStore();
  init();
  var defs = root12();
  validate_each_keys(() => store.markers, (marker) => marker.id);
  each(defs, 5, () => store.markers, (marker) => marker.id, ($$anchor2, marker) => {
    Marker($$anchor2, spread_props(() => get(marker)));
  });
  reset(defs);
  append($$anchor, defs);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/MarkerDefinition/Marker.svelte
Marker[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/MarkerDefinition/Marker.svelte";
var root_15 = add_locations(from_svg(`<polyline stroke-linecap="round" stroke-linejoin="round" fill="none" points="-5,-4 0,0 -5,4"></polyline>`), Marker[FILENAME], [[26, 4]]);
var root_3 = add_locations(from_svg(`<polyline stroke-linecap="round" stroke-linejoin="round" points="-5,-4 0,0 -5,4 -5,-4"></polyline>`), Marker[FILENAME], [[35, 4]]);
var root13 = add_locations(from_svg(`<marker class="svelte-flow__arrowhead" viewBox="-10 -10 20 20" refX="0" refY="0"><!></marker>`), Marker[FILENAME], [[14, 0]]);
function Marker($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Marker);
  let width = prop($$props, "width", 3, 12.5), height = prop($$props, "height", 3, 12.5), markerUnits = prop($$props, "markerUnits", 3, "strokeWidth"), orient = prop($$props, "orient", 3, "auto-start-reverse");
  var marker = root13();
  var node = child(marker);
  {
    var consequent = ($$anchor2) => {
      var polyline = root_15();
      template_effect(() => {
        set_attribute(polyline, "stroke", $$props.color);
        set_attribute(polyline, "stroke-width", $$props.strokeWidth);
      });
      append($$anchor2, polyline);
    };
    var alternate = ($$anchor2, $$elseif) => {
      {
        var consequent_1 = ($$anchor3) => {
          var polyline_1 = root_3();
          template_effect(() => {
            set_attribute(polyline_1, "stroke", $$props.color);
            set_attribute(polyline_1, "stroke-width", $$props.strokeWidth);
            set_attribute(polyline_1, "fill", $$props.color);
          });
          append($$anchor3, polyline_1);
        };
        if_block(
          $$anchor2,
          ($$render) => {
            if (strict_equals($$props.type, MarkerType.ArrowClosed)) $$render(consequent_1);
          },
          $$elseif
        );
      }
    };
    if_block(node, ($$render) => {
      if (strict_equals($$props.type, MarkerType.Arrow)) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  reset(marker);
  template_effect(() => {
    set_attribute(marker, "id", $$props.id);
    set_attribute(marker, "markerWidth", `${width()}`);
    set_attribute(marker, "markerHeight", `${height()}`);
    set_attribute(marker, "markerUnits", markerUnits());
    set_attribute(marker, "orient", orient());
  });
  append($$anchor, marker);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/EdgeRenderer.svelte
EdgeRenderer[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/container/EdgeRenderer/EdgeRenderer.svelte";
var root14 = add_locations(from_html(`<div class="svelte-flow__edges"><svg class="svelte-flow__marker"><!></svg> <!></div>`), EdgeRenderer[FILENAME], [[12, 0, [[13, 2]]]]);
function EdgeRenderer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, EdgeRenderer);
  var $$ownership_validator = create_ownership_validator($$props);
  let store = prop($$props, "store", 15);
  var div = root14();
  var svg = child(div);
  var node = child(svg);
  MarkerDefinition(node, {});
  reset(svg);
  var node_1 = sibling(svg, 2);
  validate_each_keys(() => store().visible.edges.values(), (edge) => edge.id);
  each(node_1, 17, () => store().visible.edges.values(), (edge) => edge.id, ($$anchor2, edge) => {
    {
      $$ownership_validator.binding("store", EdgeWrapper, store);
      EdgeWrapper($$anchor2, {
        get edge() {
          return get(edge);
        },
        get onedgeclick() {
          return $$props.onedgeclick;
        },
        get onedgecontextmenu() {
          return $$props.onedgecontextmenu;
        },
        get onedgepointerenter() {
          return $$props.onedgepointerenter;
        },
        get onedgepointerleave() {
          return $$props.onedgepointerleave;
        },
        get store() {
          return store();
        },
        set store($$value) {
          store($$value);
        }
      });
    }
  });
  reset(div);
  append($$anchor, div);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/components/Selection/Selection.svelte
Selection[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/Selection/Selection.svelte";
var root_16 = add_locations(from_html(`<div class="svelte-flow__selection svelte-1iugwpu"></div>`), Selection[FILENAME], [[12, 2]]);
var $$css3 = {
  hash: "svelte-1iugwpu",
  code: "\r\n  .svelte-flow__selection.svelte-1iugwpu {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n  }\r\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2VsZWN0aW9uLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUEyQk87QUFDUCxFQUFFLHNDQUF1QixDQUFDO0FBQzFCLElBQUksa0JBQWtCO0FBQ3RCLElBQUksTUFBTTtBQUNWLElBQUksT0FBTztBQUNYLEdBQUciLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIlNlbGVjdGlvbi5zdmVsdGUiXX0= */"
};
function Selection($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Selection);
  append_styles($$anchor, $$css3);
  let x = prop($$props, "x", 3, 0), y = prop($$props, "y", 3, 0), width = prop($$props, "width", 3, 0), height = prop($$props, "height", 3, 0), isVisible = prop($$props, "isVisible", 3, true);
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var div = root_16();
      let styles;
      template_effect(
        ($0, $1) => styles = set_style(div, "", styles, {
          width: $0,
          height: $1,
          transform: `translate(${x()}px, ${y()}px)`
        }),
        [
          () => strict_equals(typeof width(), "string") ? width() : toPxString(width()),
          () => strict_equals(typeof height(), "string") ? height() : toPxString(height())
        ]
      );
      append($$anchor2, div);
    };
    if_block(node, ($$render) => {
      if (isVisible()) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/components/NodeSelection/NodeSelection.svelte
NodeSelection[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/NodeSelection/NodeSelection.svelte";
function oncontextmenu(event2, $$props) {
  var _a;
  const selectedNodes = $$props.store.nodes.filter((n) => n.selected);
  (_a = $$props.onselectioncontextmenu) == null ? void 0 : _a.call($$props, { nodes: selectedNodes, event: event2 });
}
function onclick(event2, $$props) {
  var _a;
  const selectedNodes = $$props.store.nodes.filter((n) => n.selected);
  (_a = $$props.onselectionclick) == null ? void 0 : _a.call($$props, { nodes: selectedNodes, event: event2 });
}
var root_17 = add_locations(from_html(`<div><!></div>`), NodeSelection[FILENAME], [[45, 2]]);
var $$css4 = {
  hash: "svelte-16qgzgd",
  code: "\r\n  .svelte-flow__selection-wrapper.svelte-16qgzgd {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    z-index: 2000;\r\n    pointer-events: all;\r\n  }\r\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTm9kZVNlbGVjdGlvbi5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBc0ZPO0FBQ1AsRUFBRSw4Q0FBK0IsQ0FBQztBQUNsQyxJQUFJLGtCQUFrQjtBQUN0QixJQUFJLE1BQU07QUFDVixJQUFJLE9BQU87QUFDWCxJQUFJLGFBQWE7QUFDakIsSUFBSSxtQkFBbUI7QUFDdkIsR0FBRyIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiTm9kZVNlbGVjdGlvbi5zdmVsdGUiXX0= */"
};
function NodeSelection($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, NodeSelection);
  append_styles($$anchor, $$css4);
  let ref = tag(state(void 0), "ref");
  user_effect(() => {
    var _a;
    if (!$$props.store.disableKeyboardA11y) {
      (_a = get(ref)) == null ? void 0 : _a.focus({ preventScroll: true });
    }
  });
  let bounds = tag(
    user_derived(() => {
      if (strict_equals($$props.store.selectionRectMode, "nodes")) {
        $$props.store.nodes;
        return getInternalNodesBounds($$props.store.nodeLookup, { filter: (node) => !!node.selected });
      }
      return null;
    }),
    "bounds"
  );
  function onkeydown(event2) {
    if (Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event2.key)) {
      event2.preventDefault();
      $$props.store.moveSelectedNodes(arrowKeyDiffs[event2.key], event2.shiftKey ? 4 : 1);
    }
  }
  var fragment = comment();
  var node_1 = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var div = root_17();
      div.__contextmenu = [oncontextmenu, $$props];
      div.__click = [onclick, $$props];
      div.__keydown = function(...$$args) {
        apply(() => $$props.store.disableKeyboardA11y ? void 0 : onkeydown, this, $$args, NodeSelection, [67, 15]);
      };
      let styles;
      var node_2 = child(div);
      Selection(node_2, { width: "100%", height: "100%", x: 0, y: 0 });
      reset(div);
      action(div, ($$node, $$action_arg) => {
        var _a;
        return (_a = drag) == null ? void 0 : _a($$node, $$action_arg);
      }, () => ({
        disabled: false,
        store: $$props.store,
        onDrag: (event2, _, __, nodes) => {
          var _a;
          (_a = $$props.onnodedrag) == null ? void 0 : _a.call($$props, { event: event2, targetNode: null, nodes });
        },
        onDragStart: (event2, _, __, nodes) => {
          var _a;
          (_a = $$props.onnodedragstart) == null ? void 0 : _a.call($$props, { event: event2, targetNode: null, nodes });
        },
        onDragStop: (event2, _, __, nodes) => {
          var _a;
          (_a = $$props.onnodedragstop) == null ? void 0 : _a.call($$props, { event: event2, targetNode: null, nodes });
        }
      }));
      bind_this(div, ($$value) => set(ref, $$value), () => get(ref));
      template_effect(
        ($0, $1) => {
          set_class(
            div,
            1,
            clsx([
              "svelte-flow__selection-wrapper",
              $$props.store.noPanClass
            ]),
            "svelte-16qgzgd"
          );
          set_attribute(div, "role", $$props.store.disableKeyboardA11y ? void 0 : "button");
          set_attribute(div, "tabindex", $$props.store.disableKeyboardA11y ? void 0 : -1);
          styles = set_style(div, "", styles, {
            width: $0,
            height: $1,
            transform: `translate(${get(bounds).x ?? ""}px, ${get(bounds).y ?? ""}px)`
          });
        },
        [
          () => toPxString(get(bounds).width),
          () => toPxString(get(bounds).height)
        ]
      );
      append($$anchor2, div);
    };
    if_block(node_1, ($$render) => {
      if (strict_equals($$props.store.selectionRectMode, "nodes") && get(bounds) && isNumeric(get(bounds).x) && isNumeric(get(bounds).y)) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
delegate(["contextmenu", "click", "keydown"]);

// node_modules/@svelte-put/shortcut/src/shortcut.js
function mapModifierToBitMask(def) {
  switch (def) {
    case "ctrl":
      return 8;
    case "shift":
      return 4;
    case "alt":
      return 2;
    case "meta":
      return 1;
  }
}
function shortcut(node, param) {
  let { enabled = true, trigger, type = "keydown" } = param;
  function handler(event2) {
    var _a;
    const normalizedTriggers = Array.isArray(trigger) ? trigger : [trigger];
    const modifierMask = [event2.metaKey, event2.altKey, event2.shiftKey, event2.ctrlKey].reduce(
      (acc, value, index) => {
        if (value) {
          return acc | 1 << index;
        }
        return acc;
      },
      0
    );
    for (const trigger2 of normalizedTriggers) {
      const mergedTrigger = {
        preventDefault: false,
        enabled: true,
        ...trigger2
      };
      const { modifier, key: key2, callback, preventDefault, enabled: triggerEnabled } = mergedTrigger;
      if (triggerEnabled) {
        if (event2.key !== key2) continue;
        if (modifier === null || modifier === false) {
          if (modifierMask !== 0) continue;
        } else if (modifier !== void 0 && ((_a = modifier == null ? void 0 : modifier[0]) == null ? void 0 : _a.length) > 0) {
          const orDefs = Array.isArray(modifier) ? modifier : [modifier];
          let modified = false;
          for (const orDef of orDefs) {
            const mask = (Array.isArray(orDef) ? orDef : [orDef]).reduce(
              (acc, def) => acc | mapModifierToBitMask(def),
              0
            );
            if (mask === modifierMask) {
              modified = true;
              break;
            }
          }
          if (!modified) continue;
        }
        if (preventDefault) event2.preventDefault();
        const detail = {
          node,
          trigger: mergedTrigger,
          originalEvent: event2
        };
        node.dispatchEvent(new CustomEvent("shortcut", { detail }));
        callback == null ? void 0 : callback(detail);
      }
    }
  }
  let off;
  if (enabled) {
    off = on(node, type, handler);
  }
  return {
    update: (update) => {
      const { enabled: newEnabled = true, type: newType = "keydown" } = update;
      if (enabled && (!newEnabled || type !== newType)) {
        off == null ? void 0 : off();
      } else if (!enabled && newEnabled) {
        off = on(node, newType, handler);
      }
      enabled = newEnabled;
      type = newType;
      trigger = update.trigger;
    },
    destroy: () => {
      off == null ? void 0 : off();
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useSvelteFlow.svelte.js
function useSvelteFlow() {
  const store = user_derived(useStore);
  const getNodeRect = (node) => {
    var _a, _b;
    const nodeToUse = isNode(node) ? node : get(store).nodeLookup.get(node.id);
    const position = nodeToUse.parentId ? evaluateAbsolutePosition(nodeToUse.position, nodeToUse.measured, nodeToUse.parentId, get(store).nodeLookup, get(store).nodeOrigin) : nodeToUse.position;
    const nodeWithPosition = {
      ...nodeToUse,
      position,
      width: ((_a = nodeToUse.measured) == null ? void 0 : _a.width) ?? nodeToUse.width,
      height: ((_b = nodeToUse.measured) == null ? void 0 : _b.height) ?? nodeToUse.height
    };
    return nodeToRect(nodeWithPosition);
  };
  function updateNode(id, nodeUpdate, options = { replace: false }) {
    get(store).nodes = untrack(() => get(store).nodes).map((node) => {
      if (node.id === id) {
        const nextNode = typeof nodeUpdate === "function" ? nodeUpdate(node) : nodeUpdate;
        return (options == null ? void 0 : options.replace) && isNode(nextNode) ? nextNode : { ...node, ...nextNode };
      }
      return node;
    });
  }
  function updateEdge(id, edgeUpdate, options = { replace: false }) {
    get(store).edges = untrack(() => get(store).edges).map((edge) => {
      if (edge.id === id) {
        const nextEdge = typeof edgeUpdate === "function" ? edgeUpdate(edge) : edgeUpdate;
        return options.replace && isEdge(nextEdge) ? nextEdge : { ...edge, ...nextEdge };
      }
      return edge;
    });
  }
  const getInternalNode = (id) => get(store).nodeLookup.get(id);
  return {
    zoomIn: get(store).zoomIn,
    zoomOut: get(store).zoomOut,
    getInternalNode,
    getNode: (id) => {
      var _a;
      return (_a = getInternalNode(id)) == null ? void 0 : _a.internals.userNode;
    },
    getNodes: (ids) => ids === void 0 ? get(store).nodes : getElements(get(store).nodeLookup, ids),
    getEdge: (id) => get(store).edgeLookup.get(id),
    getEdges: (ids) => ids === void 0 ? get(store).edges : getElements(get(store).edgeLookup, ids),
    setZoom: (zoomLevel, options) => {
      const panZoom = get(store).panZoom;
      return panZoom ? panZoom.scaleTo(zoomLevel, { duration: options == null ? void 0 : options.duration }) : Promise.resolve(false);
    },
    getZoom: () => get(store).viewport.zoom,
    setViewport: async (nextViewport, options) => {
      const currentViewport = get(store).viewport;
      if (!get(store).panZoom) {
        return Promise.resolve(false);
      }
      await get(store).panZoom.setViewport(
        {
          x: nextViewport.x ?? currentViewport.x,
          y: nextViewport.y ?? currentViewport.y,
          zoom: nextViewport.zoom ?? currentViewport.zoom
        },
        options
      );
      return Promise.resolve(true);
    },
    getViewport: () => snapshot(get(store).viewport),
    setCenter: async (x, y, options) => get(store).setCenter(x, y, options),
    fitView: (options) => get(store).fitView(options),
    fitBounds: async (bounds, options) => {
      if (!get(store).panZoom) {
        return Promise.resolve(false);
      }
      const viewport = getViewportForBounds(bounds, get(store).width, get(store).height, get(store).minZoom, get(store).maxZoom, (options == null ? void 0 : options.padding) ?? 0.1);
      await get(store).panZoom.setViewport(viewport, {
        duration: options == null ? void 0 : options.duration,
        ease: options == null ? void 0 : options.ease,
        interpolate: options == null ? void 0 : options.interpolate
      });
      return Promise.resolve(true);
    },
    getIntersectingNodes: (nodeOrRect, partially = true, nodesToIntersect) => {
      const isRect = isRectObject(nodeOrRect);
      const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);
      if (!nodeRect) {
        return [];
      }
      return (nodesToIntersect || get(store).nodes).filter((n) => {
        const internalNode = get(store).nodeLookup.get(n.id);
        if (!internalNode || !isRect && n.id === nodeOrRect.id) {
          return false;
        }
        const currNodeRect = nodeToRect(internalNode);
        const overlappingArea = getOverlappingArea(currNodeRect, nodeRect);
        const partiallyVisible = partially && overlappingArea > 0;
        return partiallyVisible || overlappingArea >= currNodeRect.width * currNodeRect.height || overlappingArea >= nodeRect.width * nodeRect.height;
      });
    },
    isNodeIntersecting: (nodeOrRect, area, partially = true) => {
      const isRect = isRectObject(nodeOrRect);
      const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);
      if (!nodeRect) {
        return false;
      }
      const overlappingArea = getOverlappingArea(nodeRect, area);
      const partiallyVisible = partially && overlappingArea > 0;
      return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;
    },
    deleteElements: async ({
      nodes: nodesToRemove = [],
      edges: edgesToRemove = []
    }) => {
      const { nodes: matchingNodes, edges: matchingEdges } = await getElementsToRemove({
        nodesToRemove,
        edgesToRemove,
        nodes: get(store).nodes,
        edges: get(store).edges,
        onBeforeDelete: get(store).onbeforedelete
      });
      if (matchingNodes) {
        get(store).nodes = untrack(() => get(store).nodes).filter((node) => !matchingNodes.some(({ id }) => id === node.id));
      }
      if (matchingEdges) {
        get(store).edges = untrack(() => get(store).edges).filter((edge) => !matchingEdges.some(({ id }) => id === edge.id));
      }
      return {
        deletedNodes: matchingNodes,
        deletedEdges: matchingEdges
      };
    },
    screenToFlowPosition: (position, options = { snapToGrid: true }) => {
      if (!get(store).domNode) {
        return position;
      }
      const _snapGrid = options.snapToGrid ? get(store).snapGrid : false;
      const { x, y, zoom: zoom2 } = get(store).viewport;
      const { x: domX, y: domY } = get(store).domNode.getBoundingClientRect();
      const correctedPosition = { x: position.x - domX, y: position.y - domY };
      return pointToRendererPoint(correctedPosition, [x, y, zoom2], _snapGrid !== null, _snapGrid || [1, 1]);
    },
    /**
     *
     * @param position
     * @returns
     */
    flowToScreenPosition: (position) => {
      if (!get(store).domNode) {
        return position;
      }
      const { x, y, zoom: zoom2 } = get(store).viewport;
      const { x: domX, y: domY } = get(store).domNode.getBoundingClientRect();
      const rendererPosition = rendererPointToPoint(position, [x, y, zoom2]);
      return {
        x: rendererPosition.x + domX,
        y: rendererPosition.y + domY
      };
    },
    toObject: () => {
      return structuredClone({
        nodes: [...get(store).nodes],
        edges: [...get(store).edges],
        viewport: { ...get(store).viewport }
      });
    },
    updateNode,
    updateNodeData: (id, dataUpdate, options) => {
      var _a;
      const node = (_a = get(store).nodeLookup.get(id)) == null ? void 0 : _a.internals.userNode;
      if (!node) {
        return;
      }
      const nextData = typeof dataUpdate === "function" ? dataUpdate(node) : dataUpdate;
      updateNode(id, (node2) => ({
        ...node2,
        data: (options == null ? void 0 : options.replace) ? nextData : { ...node2.data, ...nextData }
      }));
    },
    updateEdge,
    getNodesBounds: (nodes) => {
      return getNodesBounds(nodes, {
        nodeLookup: get(store).nodeLookup,
        nodeOrigin: get(store).nodeOrigin
      });
    },
    getHandleConnections: ({ type, id, nodeId }) => {
      var _a;
      return Array.from(((_a = get(store).connectionLookup.get(`${nodeId}-${type}-${id ?? null}`)) == null ? void 0 : _a.values()) ?? []);
    }
  };
}
function getElements(lookup, ids) {
  var _a;
  const result = [];
  for (const id of ids) {
    const item = lookup.get(id);
    if (item) {
      const element = "internals" in item ? (_a = item.internals) == null ? void 0 : _a.userNode : item;
      result.push(element);
    }
  }
  return result;
}

// node_modules/@xyflow/svelte/dist/lib/components/KeyHandler/KeyHandler.svelte
KeyHandler[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/KeyHandler/KeyHandler.svelte";
function KeyHandler($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, KeyHandler);
  var $$ownership_validator = create_ownership_validator($$props);
  let store = prop($$props, "store", 15), selectionKey = prop($$props, "selectionKey", 3, "Shift"), multiSelectionKey = prop($$props, "multiSelectionKey", 19, () => isMacOs() ? "Meta" : "Control"), deleteKey = prop($$props, "deleteKey", 3, "Backspace"), panActivationKey = prop($$props, "panActivationKey", 3, " "), zoomActivationKey = prop($$props, "zoomActivationKey", 19, () => isMacOs() ? "Meta" : "Control");
  let { deleteElements } = useSvelteFlow();
  function isKeyObject(key2) {
    return strict_equals(key2, null, false) && strict_equals(typeof key2, "object");
  }
  function getModifier(key2) {
    return isKeyObject(key2) ? key2.modifier || [] : [];
  }
  function getKeyString(key2) {
    if (strict_equals(key2, null) || strict_equals(key2, void 0)) {
      return "";
    }
    return isKeyObject(key2) ? key2.key : key2;
  }
  function getShortcutTrigger(key2, callback) {
    const keys = Array.isArray(key2) ? key2 : [key2];
    return keys.map((_key) => {
      const keyString = getKeyString(_key);
      return {
        key: keyString,
        modifier: getModifier(_key),
        enabled: strict_equals(keyString, null, false),
        callback
      };
    });
  }
  function resetKeysAndSelection() {
    $$ownership_validator.mutation("store", ["store", "selectionRect"], store(store().selectionRect = null, true), 40, 2);
    $$ownership_validator.mutation("store", ["store", "selectionKeyPressed"], store(store().selectionKeyPressed = false, true), 41, 2);
    $$ownership_validator.mutation("store", ["store", "multiselectionKeyPressed"], store(store().multiselectionKeyPressed = false, true), 42, 2);
    $$ownership_validator.mutation("store", ["store", "deleteKeyPressed"], store(store().deleteKeyPressed = false, true), 43, 2);
    $$ownership_validator.mutation("store", ["store", "panActivationKeyPressed"], store(store().panActivationKeyPressed = false, true), 44, 2);
    $$ownership_validator.mutation("store", ["store", "zoomActivationKeyPressed"], store(store().zoomActivationKeyPressed = false, true), 45, 2);
  }
  async function handleDelete() {
    var _a, _b;
    const selectedNodes = store().nodes.filter((node) => node.selected);
    const selectedEdges = store().edges.filter((edge) => edge.selected);
    const { deletedNodes, deletedEdges } = await deleteElements({ nodes: selectedNodes, edges: selectedEdges });
    if (deletedNodes.length > 0 || deletedEdges.length > 0) {
      (_b = (_a = store()).ondelete) == null ? void 0 : _b.call(_a, { nodes: deletedNodes, edges: deletedEdges });
    }
  }
  event("blur", $window, resetKeysAndSelection);
  event("contextmenu", $window, resetKeysAndSelection);
  action($window, ($$node, $$action_arg) => {
    var _a;
    return (_a = shortcut) == null ? void 0 : _a($$node, $$action_arg);
  }, () => ({
    trigger: getShortcutTrigger(selectionKey(), () => $$ownership_validator.mutation("store", ["store", "selectionKeyPressed"], store(store().selectionKeyPressed = true, true), 67, 53)),
    type: "keydown"
  }));
  action($window, ($$node, $$action_arg) => {
    var _a;
    return (_a = shortcut) == null ? void 0 : _a($$node, $$action_arg);
  }, () => ({
    trigger: getShortcutTrigger(selectionKey(), () => $$ownership_validator.mutation("store", ["store", "selectionKeyPressed"], store(store().selectionKeyPressed = false, true), 71, 53)),
    type: "keyup"
  }));
  action($window, ($$node, $$action_arg) => {
    var _a;
    return (_a = shortcut) == null ? void 0 : _a($$node, $$action_arg);
  }, () => ({
    trigger: getShortcutTrigger(multiSelectionKey(), () => {
      $$ownership_validator.mutation("store", ["store", "multiselectionKeyPressed"], store(store().multiselectionKeyPressed = true, true), 76, 6);
    }),
    type: "keydown"
  }));
  action($window, ($$node, $$action_arg) => {
    var _a;
    return (_a = shortcut) == null ? void 0 : _a($$node, $$action_arg);
  }, () => ({
    trigger: getShortcutTrigger(multiSelectionKey(), () => $$ownership_validator.mutation("store", ["store", "multiselectionKeyPressed"], store(store().multiselectionKeyPressed = false, true), 81, 58)),
    type: "keyup"
  }));
  action($window, ($$node, $$action_arg) => {
    var _a;
    return (_a = shortcut) == null ? void 0 : _a($$node, $$action_arg);
  }, () => ({
    trigger: getShortcutTrigger(deleteKey(), (detail) => {
      const isModifierKey = detail.originalEvent.ctrlKey || detail.originalEvent.metaKey || detail.originalEvent.shiftKey;
      if (!isModifierKey && !isInputDOMNode(detail.originalEvent)) {
        $$ownership_validator.mutation("store", ["store", "deleteKeyPressed"], store(store().deleteKeyPressed = true, true), 91, 8);
        handleDelete();
      }
    }),
    type: "keydown"
  }));
  action($window, ($$node, $$action_arg) => {
    var _a;
    return (_a = shortcut) == null ? void 0 : _a($$node, $$action_arg);
  }, () => ({
    trigger: getShortcutTrigger(deleteKey(), () => $$ownership_validator.mutation("store", ["store", "deleteKeyPressed"], store(store().deleteKeyPressed = false, true), 98, 50)),
    type: "keyup"
  }));
  action($window, ($$node, $$action_arg) => {
    var _a;
    return (_a = shortcut) == null ? void 0 : _a($$node, $$action_arg);
  }, () => ({
    trigger: getShortcutTrigger(panActivationKey(), () => $$ownership_validator.mutation("store", ["store", "panActivationKeyPressed"], store(store().panActivationKeyPressed = true, true), 102, 57)),
    type: "keydown"
  }));
  action($window, ($$node, $$action_arg) => {
    var _a;
    return (_a = shortcut) == null ? void 0 : _a($$node, $$action_arg);
  }, () => ({
    trigger: getShortcutTrigger(panActivationKey(), () => $$ownership_validator.mutation("store", ["store", "panActivationKeyPressed"], store(store().panActivationKeyPressed = false, true), 106, 57)),
    type: "keyup"
  }));
  action($window, ($$node, $$action_arg) => {
    var _a;
    return (_a = shortcut) == null ? void 0 : _a($$node, $$action_arg);
  }, () => ({
    trigger: getShortcutTrigger(zoomActivationKey(), () => $$ownership_validator.mutation("store", ["store", "zoomActivationKeyPressed"], store(store().zoomActivationKeyPressed = true, true), 110, 58)),
    type: "keydown"
  }));
  action($window, ($$node, $$action_arg) => {
    var _a;
    return (_a = shortcut) == null ? void 0 : _a($$node, $$action_arg);
  }, () => ({
    trigger: getShortcutTrigger(zoomActivationKey(), () => $$ownership_validator.mutation("store", ["store", "zoomActivationKeyPressed"], store(store().zoomActivationKeyPressed = false, true), 114, 58)),
    type: "keyup"
  }));
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/components/ConnectionLine/ConnectionLine.svelte
ConnectionLine[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/ConnectionLine/ConnectionLine.svelte";
var root_32 = add_locations(from_svg(`<path fill="none" class="svelte-flow__connection-path"></path>`), ConnectionLine[FILENAME], [[59, 8]]);
var root_18 = add_locations(from_svg(`<svg class="svelte-flow__connectionline"><g><!></g></svg>`), ConnectionLine[FILENAME], [[49, 2, [[55, 4]]]]);
function ConnectionLine($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, ConnectionLine);
  let path = tag(
    user_derived(() => {
      if (!$$props.store.connection.inProgress) {
        return "";
      }
      const pathParams = {
        sourceX: $$props.store.connection.from.x,
        sourceY: $$props.store.connection.from.y,
        sourcePosition: $$props.store.connection.fromPosition,
        targetX: $$props.store.connection.to.x,
        targetY: $$props.store.connection.to.y,
        targetPosition: $$props.store.connection.toPosition
      };
      switch ($$props.type) {
        case ConnectionLineType.Bezier: {
          const [path2] = getBezierPath(pathParams);
          return path2;
        }
        case ConnectionLineType.Straight: {
          const [path2] = getStraightPath(pathParams);
          return path2;
        }
        case ConnectionLineType.Step:
        case ConnectionLineType.SmoothStep: {
          const [path2] = getSmoothStepPath({
            ...pathParams,
            borderRadius: strict_equals($$props.type, ConnectionLineType.Step) ? 0 : void 0
          });
          return path2;
        }
      }
    }),
    "path"
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent_1 = ($$anchor2) => {
      var svg = root_18();
      var g = child(svg);
      var node_1 = child(g);
      {
        var consequent = ($$anchor3) => {
          var fragment_1 = comment();
          var node_2 = first_child(fragment_1);
          component(node_2, () => $$props.LineComponent, ($$anchor4, LineComponent_1) => {
            LineComponent_1($$anchor4, {});
          });
          append($$anchor3, fragment_1);
        };
        var alternate = ($$anchor3) => {
          var path_1 = root_32();
          template_effect(() => {
            set_attribute(path_1, "d", get(path));
            set_style(path_1, $$props.style);
          });
          append($$anchor3, path_1);
        };
        if_block(node_1, ($$render) => {
          if ($$props.LineComponent) $$render(consequent);
          else $$render(alternate, false);
        });
      }
      reset(g);
      reset(svg);
      template_effect(
        ($0) => {
          set_attribute(svg, "width", $$props.store.width);
          set_attribute(svg, "height", $$props.store.height);
          set_style(svg, $$props.containerStyle);
          set_class(g, 0, $0);
        },
        [
          () => clsx([
            "svelte-flow__connection",
            getConnectionStatus($$props.store.connection.isValid)
          ])
        ]
      );
      append($$anchor2, svg);
    };
    if_block(node, ($$render) => {
      if ($$props.store.connection.inProgress) $$render(consequent_1);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/container/Panel/Panel.svelte
Panel[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/container/Panel/Panel.svelte";
var root15 = add_locations(from_html(`<div><!></div>`), Panel[FILENAME], [[5, 0]]);
function Panel($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Panel);
  let position = prop($$props, "position", 3, "top-right"), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "position",
      "style",
      "class",
      "children"
    ],
    "rest"
  );
  let positionClasses = tag(user_derived(() => `${position()}`.split("-")), "positionClasses");
  var div = root15();
  attribute_effect(div, ($0) => ({ class: $0, style: $$props.style, ...rest }), [
    () => [
      "svelte-flow__panel",
      $$props.class,
      ...get(positionClasses)
    ]
  ]);
  var node = child(div);
  snippet(node, () => $$props.children ?? noop);
  reset(div);
  append($$anchor, div);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/components/Attribution/Attribution.svelte
Attribution[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/Attribution/Attribution.svelte";
var root_2 = add_locations(from_html(`<a href="https://svelteflow.dev" target="_blank" rel="noopener noreferrer" aria-label="Svelte Flow attribution">Svelte Flow</a>`), Attribution[FILENAME], [[11, 4]]);
function Attribution($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Attribution);
  let position = prop($$props, "position", 3, "bottom-right");
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      Panel($$anchor2, {
        get position() {
          return position();
        },
        class: "svelte-flow__attribution",
        "data-message": "Feel free to remove the attribution or check out how you could support us: https://svelteflow.dev/support-us",
        children: wrap_snippet(Attribution, ($$anchor3, $$slotProps) => {
          var a = root_2();
          append($$anchor3, a);
        }),
        $$slots: { default: true }
      });
    };
    if_block(node, ($$render) => {
      var _a;
      if (!((_a = $$props.proOptions) == null ? void 0 : _a.hideAttribution)) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/container/SvelteFlow/Wrapper.svelte
Wrapper[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/container/SvelteFlow/Wrapper.svelte";
var root16 = add_locations(from_html(`<div><!></div>`), Wrapper[FILENAME], [[89, 0]]);
var $$css5 = {
  hash: "svelte-12wlba6",
  code: "\r\n  .svelte-flow.svelte-12wlba6 {\r\n    width: 100%;\r\n    height: 100%;\r\n    overflow: hidden;\r\n    position: relative;\r\n    z-index: 0;\r\n\r\n    background-color: var(--background-color, var(--background-color-default));\r\n  }\r\n\r\n  :root {\r\n    --background-color-default: #fff;\r\n    --background-pattern-color-default: #ddd;\r\n\r\n    --minimap-mask-color-default: rgb(240, 240, 240, 0.6);\r\n    --minimap-mask-stroke-color-default: none;\r\n    --minimap-mask-stroke-width-default: 1;\r\n\r\n    --controls-button-background-color-default: #fefefe;\r\n    --controls-button-background-color-hover-default: #f4f4f4;\r\n    --controls-button-color-default: inherit;\r\n    --controls-button-color-hover-default: inherit;\r\n    --controls-button-border-color-default: #eee;\r\n  }\r\n\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiV3JhcHBlci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBbUlPO0FBQ1AsRUFBRSwyQkFBWSxDQUFDO0FBQ2YsSUFBSSxXQUFXO0FBQ2YsSUFBSSxZQUFZO0FBQ2hCLElBQUksZ0JBQWdCO0FBQ3BCLElBQUksa0JBQWtCO0FBQ3RCLElBQUksVUFBVTtBQUNkO0FBQ0EsSUFBSSwwRUFBMEU7QUFDOUUsR0FBRztBQUNIO0FBQ0EsRUFBRSxLQUFLLENBQUM7QUFDUixJQUFJLGdDQUFnQztBQUNwQyxJQUFJLHdDQUF3QztBQUM1QztBQUNBLElBQUkscURBQXFEO0FBQ3pELElBQUkseUNBQXlDO0FBQzdDLElBQUksc0NBQXNDO0FBQzFDO0FBQ0EsSUFBSSxtREFBbUQ7QUFDdkQsSUFBSSx5REFBeUQ7QUFDN0QsSUFBSSx3Q0FBd0M7QUFDNUMsSUFBSSw4Q0FBOEM7QUFDbEQsSUFBSSw0Q0FBNEM7QUFDaEQsR0FBRyIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiV3JhcHBlci5zdmVsdGUiXX0= */"
};
function Wrapper($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Wrapper);
  append_styles($$anchor, $$css5);
  let domNode = prop($$props, "domNode", 15), clientWidth = prop($$props, "clientWidth", 15), clientHeight = prop($$props, "clientHeight", 15);
  let id = tag(user_derived(() => $$props.rest.id), "id"), className = tag(user_derived(() => $$props.rest.class), "className"), nodeTypes = tag(user_derived(() => $$props.rest.nodeTypes), "nodeTypes"), edgeTypes = tag(user_derived(() => $$props.rest.edgeTypes), "edgeTypes"), _colorMode = tag(user_derived(() => $$props.rest.colorMode), "_colorMode"), isValidConnection = tag(user_derived(() => $$props.rest.isValidConnection), "isValidConnection"), onmove = tag(user_derived(() => $$props.rest.onmove), "onmove"), onmovestart = tag(user_derived(() => $$props.rest.onmovestart), "onmovestart"), onmoveend = tag(user_derived(() => $$props.rest.onmoveend), "onmoveend"), onflowerror = tag(user_derived(() => $$props.rest.onflowerror), "onflowerror"), ondelete = tag(user_derived(() => $$props.rest.ondelete), "ondelete"), onbeforedelete = tag(user_derived(() => $$props.rest.onbeforedelete), "onbeforedelete"), onbeforeconnect = tag(user_derived(() => $$props.rest.onbeforeconnect), "onbeforeconnect"), onconnect = tag(user_derived(() => $$props.rest.onconnect), "onconnect"), onconnectstart = tag(user_derived(() => $$props.rest.onconnectstart), "onconnectstart"), onconnectend = tag(user_derived(() => $$props.rest.onconnectend), "onconnectend"), onbeforereconnect = tag(user_derived(() => $$props.rest.onbeforereconnect), "onbeforereconnect"), onreconnect = tag(user_derived(() => $$props.rest.onreconnect), "onreconnect"), onreconnectstart = tag(user_derived(() => $$props.rest.onreconnectstart), "onreconnectstart"), onreconnectend = tag(user_derived(() => $$props.rest.onreconnectend), "onreconnectend"), onclickconnectstart = tag(user_derived(() => $$props.rest.onclickconnectstart), "onclickconnectstart"), onclickconnectend = tag(user_derived(() => $$props.rest.onclickconnectend), "onclickconnectend"), oninit = tag(user_derived(() => $$props.rest.oninit), "oninit"), onselectionchange = tag(user_derived(() => $$props.rest.onselectionchange), "onselectionchange"), onselectiondragstart = tag(user_derived(() => $$props.rest.onselectiondragstart), "onselectiondragstart"), onselectiondrag = tag(user_derived(() => $$props.rest.onselectiondrag), "onselectiondrag"), onselectiondragstop = tag(user_derived(() => $$props.rest.onselectiondragstop), "onselectiondragstop"), onselectionstart = tag(user_derived(() => $$props.rest.onselectionstart), "onselectionstart"), onselectionend = tag(user_derived(() => $$props.rest.onselectionend), "onselectionend"), clickConnect = tag(user_derived(() => $$props.rest.clickConnect), "clickConnect"), fitView = tag(user_derived(() => $$props.rest.fitView), "fitView"), fitViewOptions = tag(user_derived(() => $$props.rest.fitViewOptions), "fitViewOptions"), nodeOrigin = tag(user_derived(() => $$props.rest.nodeOrigin), "nodeOrigin"), nodeDragThreshold = tag(user_derived(() => $$props.rest.nodeDragThreshold), "nodeDragThreshold"), connectionDragThreshold = tag(user_derived(() => $$props.rest.connectionDragThreshold), "connectionDragThreshold"), minZoom = tag(user_derived(() => $$props.rest.minZoom), "minZoom"), maxZoom = tag(user_derived(() => $$props.rest.maxZoom), "maxZoom"), initialViewport = tag(user_derived(() => $$props.rest.initialViewport), "initialViewport"), connectionRadius = tag(user_derived(() => $$props.rest.connectionRadius), "connectionRadius"), connectionMode = tag(user_derived(() => $$props.rest.connectionMode), "connectionMode"), selectionMode = tag(user_derived(() => $$props.rest.selectionMode), "selectionMode"), selectNodesOnDrag = tag(user_derived(() => $$props.rest.selectNodesOnDrag), "selectNodesOnDrag"), snapGrid = tag(user_derived(() => $$props.rest.snapGrid), "snapGrid"), defaultMarkerColor = tag(user_derived(() => $$props.rest.defaultMarkerColor), "defaultMarkerColor"), translateExtent = tag(user_derived(() => $$props.rest.translateExtent), "translateExtent"), nodeExtent = tag(user_derived(() => $$props.rest.nodeExtent), "nodeExtent"), onlyRenderVisibleElements = tag(user_derived(() => $$props.rest.onlyRenderVisibleElements), "onlyRenderVisibleElements"), autoPanOnConnect = tag(user_derived(() => $$props.rest.autoPanOnConnect), "autoPanOnConnect"), autoPanOnNodeDrag = tag(user_derived(() => $$props.rest.autoPanOnNodeDrag), "autoPanOnNodeDrag"), colorModeSSR = tag(user_derived(() => $$props.rest.colorModeSSR), "colorModeSSR"), style = tag(user_derived(() => $$props.rest.style), "style"), defaultEdgeOptions = tag(user_derived(() => $$props.rest.defaultEdgeOptions), "defaultEdgeOptions"), elevateNodesOnSelect = tag(user_derived(() => $$props.rest.elevateNodesOnSelect), "elevateNodesOnSelect"), elevateEdgesOnSelect = tag(user_derived(() => $$props.rest.elevateEdgesOnSelect), "elevateEdgesOnSelect"), nodesDraggable = tag(user_derived(() => $$props.rest.nodesDraggable), "nodesDraggable"), autoPanOnNodeFocus = tag(user_derived(() => $$props.rest.autoPanOnNodeFocus), "autoPanOnNodeFocus"), nodesConnectable = tag(user_derived(() => $$props.rest.nodesConnectable), "nodesConnectable"), elementsSelectable = tag(user_derived(() => $$props.rest.elementsSelectable), "elementsSelectable"), nodesFocusable = tag(user_derived(() => $$props.rest.nodesFocusable), "nodesFocusable"), edgesFocusable = tag(user_derived(() => $$props.rest.edgesFocusable), "edgesFocusable"), disableKeyboardA11y = tag(user_derived(() => $$props.rest.disableKeyboardA11y), "disableKeyboardA11y"), noDragClass = tag(user_derived(() => $$props.rest.noDragClass), "noDragClass"), noPanClass = tag(user_derived(() => $$props.rest.noPanClass), "noPanClass"), noWheelClass = tag(user_derived(() => $$props.rest.noWheelClass), "noWheelClass"), ariaLabelConfig = tag(user_derived(() => $$props.rest.ariaLabelConfig), "ariaLabelConfig"), divAttributes = tag(
    user_derived(() => exclude_from_object($$props.rest, [
      "id",
      "class",
      "nodeTypes",
      "edgeTypes",
      "colorMode",
      "isValidConnection",
      "onmove",
      "onmovestart",
      "onmoveend",
      "onflowerror",
      "ondelete",
      "onbeforedelete",
      "onbeforeconnect",
      "onconnect",
      "onconnectstart",
      "onconnectend",
      "onbeforereconnect",
      "onreconnect",
      "onreconnectstart",
      "onreconnectend",
      "onclickconnectstart",
      "onclickconnectend",
      "oninit",
      "onselectionchange",
      "onselectiondragstart",
      "onselectiondrag",
      "onselectiondragstop",
      "onselectionstart",
      "onselectionend",
      "clickConnect",
      "fitView",
      "fitViewOptions",
      "nodeOrigin",
      "nodeDragThreshold",
      "connectionDragThreshold",
      "minZoom",
      "maxZoom",
      "initialViewport",
      "connectionRadius",
      "connectionMode",
      "selectionMode",
      "selectNodesOnDrag",
      "snapGrid",
      "defaultMarkerColor",
      "translateExtent",
      "nodeExtent",
      "onlyRenderVisibleElements",
      "autoPanOnConnect",
      "autoPanOnNodeDrag",
      "colorModeSSR",
      "style",
      "defaultEdgeOptions",
      "elevateNodesOnSelect",
      "elevateEdgesOnSelect",
      "nodesDraggable",
      "autoPanOnNodeFocus",
      "nodesConnectable",
      "elementsSelectable",
      "nodesFocusable",
      "edgesFocusable",
      "disableKeyboardA11y",
      "noDragClass",
      "noPanClass",
      "noWheelClass",
      "ariaLabelConfig"
    ])),
    "divAttributes"
  );
  function wrapperOnScroll(e) {
    e.currentTarget.scrollTo({ top: 0, left: 0, behavior: "auto" });
    if ($$props.rest.onscroll) {
      $$props.rest.onscroll(e);
    }
  }
  var div = root16();
  attribute_effect(
    div,
    ($0, $1) => ({
      class: [
        "svelte-flow",
        "svelte-flow__container",
        get(className),
        $$props.colorMode
      ],
      "data-testid": "svelte-flow__wrapper",
      role: "application",
      onscroll: wrapperOnScroll,
      ...get(divAttributes),
      [STYLE]: { width: $0, height: $1 }
    }),
    [
      () => toPxString($$props.width),
      () => toPxString($$props.height)
    ],
    "svelte-12wlba6"
  );
  var node = child(div);
  snippet(node, () => $$props.children ?? noop);
  reset(div);
  bind_this(div, ($$value) => domNode($$value), () => domNode());
  bind_element_size(div, "clientHeight", clientHeight);
  bind_element_size(div, "clientWidth", clientWidth);
  append($$anchor, div);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/container/SvelteFlow/SvelteFlow.svelte
SvelteFlow[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/container/SvelteFlow/SvelteFlow.svelte";
var root_4 = add_locations(from_html(`<div class="svelte-flow__viewport-back svelte-flow__container"></div> <!> <div class="svelte-flow__edge-labels svelte-flow__container"></div> <!> <!> <!> <div class="svelte-flow__viewport-front svelte-flow__container"></div>`, 1), SvelteFlow[FILENAME], [[156, 8], [164, 8], [192, 8]]);
var root_33 = add_locations(from_html(`<!> <!>`, 1), SvelteFlow[FILENAME], []);
var root_19 = add_locations(from_html(`<!> <!> <!> <!> <!>`, 1), SvelteFlow[FILENAME], []);
function SvelteFlow($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, SvelteFlow);
  let paneClickDistance = prop($$props, "paneClickDistance", 3, 1), nodeClickDistance = prop($$props, "nodeClickDistance", 3, 1), panOnScrollMode = prop($$props, "panOnScrollMode", 19, () => PanOnScrollMode.Free), preventScrolling = prop($$props, "preventScrolling", 3, true), zoomOnScroll = prop($$props, "zoomOnScroll", 3, true), zoomOnDoubleClick = prop($$props, "zoomOnDoubleClick", 3, true), zoomOnPinch = prop($$props, "zoomOnPinch", 3, true), panOnScroll = prop($$props, "panOnScroll", 3, false), panOnDrag = prop($$props, "panOnDrag", 3, true), selectionOnDrag = prop($$props, "selectionOnDrag", 3, true), connectionLineType = prop($$props, "connectionLineType", 19, () => ConnectionLineType.Bezier), nodes = prop($$props, "nodes", 31, () => tag_proxy(proxy([]), "nodes")), edges = prop($$props, "edges", 31, () => tag_proxy(proxy([]), "edges")), viewport = prop($$props, "viewport", 31, () => void 0), props = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "width",
      "height",
      "proOptions",
      "selectionKey",
      "deleteKey",
      "panActivationKey",
      "multiSelectionKey",
      "zoomActivationKey",
      "paneClickDistance",
      "nodeClickDistance",
      "onmovestart",
      "onmoveend",
      "onmove",
      "oninit",
      "onnodeclick",
      "onnodecontextmenu",
      "onnodedrag",
      "onnodedragstart",
      "onnodedragstop",
      "onnodepointerenter",
      "onnodepointermove",
      "onnodepointerleave",
      "onselectionclick",
      "onselectioncontextmenu",
      "onselectionstart",
      "onselectionend",
      "onedgeclick",
      "onedgecontextmenu",
      "onedgepointerenter",
      "onedgepointerleave",
      "onpaneclick",
      "onpanecontextmenu",
      "panOnScrollMode",
      "preventScrolling",
      "zoomOnScroll",
      "zoomOnDoubleClick",
      "zoomOnPinch",
      "panOnScroll",
      "panOnDrag",
      "selectionOnDrag",
      "connectionLineComponent",
      "connectionLineStyle",
      "connectionLineContainerStyle",
      "connectionLineType",
      "attributionPosition",
      "children",
      "nodes",
      "edges",
      "viewport"
    ],
    "props"
  );
  let store = createStore({
    props,
    width: $$props.width,
    height: $$props.height,
    get nodes() {
      return nodes();
    },
    set nodes(newNodes) {
      nodes(newNodes);
    },
    get edges() {
      return edges();
    },
    set edges(newEdges) {
      edges(newEdges);
    },
    get viewport() {
      return viewport();
    },
    set viewport(newViewport) {
      viewport(newViewport);
    }
  });
  const providerContext = getContext(key);
  if (providerContext && providerContext.setStore) {
    providerContext.setStore(store);
  }
  setContext(key, {
    provider: false,
    getStore() {
      return store;
    }
  });
  user_effect(() => {
    var _a;
    const params = {
      nodes: store.selectedNodes,
      edges: store.selectedEdges
    };
    (_a = untrack(() => $$props.onselectionchange)) == null ? void 0 : _a(params);
    for (const handler of store.selectionChangeHandlers.values()) {
      handler(params);
    }
  });
  onDestroy(() => {
    store.reset();
  });
  validate_binding("bind:domNode={store.domNode}", () => store, () => "domNode", 115, 2);
  validate_binding("bind:clientWidth={store.width}", () => store, () => "width", 116, 2);
  validate_binding("bind:clientHeight={store.height}", () => store, () => "height", 117, 2);
  Wrapper($$anchor, {
    get colorMode() {
      return store.colorMode;
    },
    get width() {
      return $$props.width;
    },
    get height() {
      return $$props.height;
    },
    get rest() {
      return props;
    },
    get domNode() {
      return store.domNode;
    },
    set domNode($$value) {
      store.domNode = $$value;
    },
    get clientWidth() {
      return store.width;
    },
    set clientWidth($$value) {
      store.width = $$value;
    },
    get clientHeight() {
      return store.height;
    },
    set clientHeight($$value) {
      store.height = $$value;
    },
    children: wrap_snippet(SvelteFlow, ($$anchor2, $$slotProps) => {
      var fragment_1 = root_19();
      var node = first_child(fragment_1);
      KeyHandler(node, {
        get selectionKey() {
          return $$props.selectionKey;
        },
        get deleteKey() {
          return $$props.deleteKey;
        },
        get panActivationKey() {
          return $$props.panActivationKey;
        },
        get multiSelectionKey() {
          return $$props.multiSelectionKey;
        },
        get zoomActivationKey() {
          return $$props.zoomActivationKey;
        },
        get store() {
          return store;
        },
        set store($$value) {
          store = $$value;
        }
      });
      var node_1 = sibling(node, 2);
      Zoom(node_1, {
        get panOnScrollMode() {
          return panOnScrollMode();
        },
        get preventScrolling() {
          return preventScrolling();
        },
        get zoomOnScroll() {
          return zoomOnScroll();
        },
        get zoomOnDoubleClick() {
          return zoomOnDoubleClick();
        },
        get zoomOnPinch() {
          return zoomOnPinch();
        },
        get panOnScroll() {
          return panOnScroll();
        },
        get panOnDrag() {
          return panOnDrag();
        },
        get paneClickDistance() {
          return paneClickDistance();
        },
        get onmovestart() {
          return $$props.onmovestart;
        },
        get onmove() {
          return $$props.onmove;
        },
        get onmoveend() {
          return $$props.onmoveend;
        },
        get oninit() {
          return $$props.oninit;
        },
        get store() {
          return store;
        },
        set store($$value) {
          store = $$value;
        },
        children: wrap_snippet(SvelteFlow, ($$anchor3, $$slotProps2) => {
          Pane($$anchor3, {
            get onpaneclick() {
              return $$props.onpaneclick;
            },
            get onpanecontextmenu() {
              return $$props.onpanecontextmenu;
            },
            get onselectionstart() {
              return $$props.onselectionstart;
            },
            get onselectionend() {
              return $$props.onselectionend;
            },
            get panOnDrag() {
              return panOnDrag();
            },
            get selectionOnDrag() {
              return selectionOnDrag();
            },
            get store() {
              return store;
            },
            set store($$value) {
              store = $$value;
            },
            children: wrap_snippet(SvelteFlow, ($$anchor4, $$slotProps3) => {
              var fragment_3 = root_33();
              var node_2 = first_child(fragment_3);
              Viewport(node_2, {
                get store() {
                  return store;
                },
                set store($$value) {
                  store = $$value;
                },
                children: wrap_snippet(SvelteFlow, ($$anchor5, $$slotProps4) => {
                  var fragment_4 = root_4();
                  var node_3 = sibling(first_child(fragment_4), 2);
                  EdgeRenderer(node_3, {
                    get onedgeclick() {
                      return $$props.onedgeclick;
                    },
                    get onedgecontextmenu() {
                      return $$props.onedgecontextmenu;
                    },
                    get onedgepointerenter() {
                      return $$props.onedgepointerenter;
                    },
                    get onedgepointerleave() {
                      return $$props.onedgepointerleave;
                    },
                    get store() {
                      return store;
                    },
                    set store($$value) {
                      store = $$value;
                    }
                  });
                  var node_4 = sibling(node_3, 4);
                  ConnectionLine(node_4, {
                    get type() {
                      return connectionLineType();
                    },
                    get LineComponent() {
                      return $$props.connectionLineComponent;
                    },
                    get containerStyle() {
                      return $$props.connectionLineContainerStyle;
                    },
                    get style() {
                      return $$props.connectionLineStyle;
                    },
                    get store() {
                      return store;
                    },
                    set store($$value) {
                      store = $$value;
                    }
                  });
                  var node_5 = sibling(node_4, 2);
                  NodeRenderer(node_5, {
                    get nodeClickDistance() {
                      return nodeClickDistance();
                    },
                    get onnodeclick() {
                      return $$props.onnodeclick;
                    },
                    get onnodecontextmenu() {
                      return $$props.onnodecontextmenu;
                    },
                    get onnodepointerenter() {
                      return $$props.onnodepointerenter;
                    },
                    get onnodepointermove() {
                      return $$props.onnodepointermove;
                    },
                    get onnodepointerleave() {
                      return $$props.onnodepointerleave;
                    },
                    get onnodedrag() {
                      return $$props.onnodedrag;
                    },
                    get onnodedragstart() {
                      return $$props.onnodedragstart;
                    },
                    get onnodedragstop() {
                      return $$props.onnodedragstop;
                    },
                    get store() {
                      return store;
                    },
                    set store($$value) {
                      store = $$value;
                    }
                  });
                  var node_6 = sibling(node_5, 2);
                  NodeSelection(node_6, {
                    get onselectionclick() {
                      return $$props.onselectionclick;
                    },
                    get onselectioncontextmenu() {
                      return $$props.onselectioncontextmenu;
                    },
                    get onnodedrag() {
                      return $$props.onnodedrag;
                    },
                    get onnodedragstart() {
                      return $$props.onnodedragstart;
                    },
                    get onnodedragstop() {
                      return $$props.onnodedragstop;
                    },
                    get store() {
                      return store;
                    },
                    set store($$value) {
                      store = $$value;
                    }
                  });
                  next(2);
                  append($$anchor5, fragment_4);
                }),
                $$slots: { default: true }
              });
              var node_7 = sibling(node_2, 2);
              const expression = user_derived(() => !!(store.selectionRect && strict_equals(store.selectionRectMode, "user")));
              const expression_1 = user_derived(() => {
                var _a;
                return (_a = store.selectionRect) == null ? void 0 : _a.width;
              });
              const expression_2 = user_derived(() => {
                var _a;
                return (_a = store.selectionRect) == null ? void 0 : _a.height;
              });
              const expression_3 = user_derived(() => {
                var _a;
                return (_a = store.selectionRect) == null ? void 0 : _a.x;
              });
              const expression_4 = user_derived(() => {
                var _a;
                return (_a = store.selectionRect) == null ? void 0 : _a.y;
              });
              Selection(node_7, {
                get isVisible() {
                  return get(expression);
                },
                get width() {
                  return get(expression_1);
                },
                get height() {
                  return get(expression_2);
                },
                get x() {
                  return get(expression_3);
                },
                get y() {
                  return get(expression_4);
                }
              });
              append($$anchor4, fragment_3);
            }),
            $$slots: { default: true }
          });
        }),
        $$slots: { default: true }
      });
      var node_8 = sibling(node_1, 2);
      Attribution(node_8, {
        get proOptions() {
          return $$props.proOptions;
        },
        get position() {
          return $$props.attributionPosition;
        }
      });
      var node_9 = sibling(node_8, 2);
      A11yDescriptions(node_9, {
        get store() {
          return store;
        }
      });
      var node_10 = sibling(node_9, 2);
      snippet(node_10, () => $$props.children ?? noop);
      append($$anchor2, fragment_1);
    }),
    $$slots: { default: true }
  });
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/components/SvelteFlowProvider/SvelteFlowProvider.svelte
SvelteFlowProvider[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/SvelteFlowProvider/SvelteFlowProvider.svelte";
function SvelteFlowProvider($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, SvelteFlowProvider);
  let store = tag(state(createStore({ props: {}, nodes: [], edges: [] })), "store");
  setContext(key, {
    provider: true,
    getStore() {
      return get(store);
    },
    setStore: (newStore) => {
      set(store, newStore);
    }
  });
  onDestroy(() => {
    get(store).reset();
  });
  var fragment = comment();
  var node = first_child(fragment);
  snippet(node, () => $$props.children ?? noop);
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/components/ViewportPortal/ViewportPortal.svelte
ViewportPortal[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/ViewportPortal/ViewportPortal.svelte";
var root17 = add_locations(from_html(`<div><!></div>`), ViewportPortal[FILENAME], [[5, 0]]);
function ViewportPortal($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, ViewportPortal);
  let target = prop($$props, "target", 3, "front"), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "target",
      "children"
    ],
    "rest"
  );
  var div = root17();
  attribute_effect(div, ($0) => ({ ...rest, [STYLE]: { display: $0 } }), [
    () => hideOnSSR().value ? "none" : void 0
  ]);
  var node = child(div);
  snippet(node, () => $$props.children ?? noop);
  reset(div);
  action(div, ($$node, $$action_arg) => {
    var _a;
    return (_a = portal) == null ? void 0 : _a($$node, $$action_arg);
  }, () => `viewport-${target()}`);
  append($$anchor, div);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/components/EdgeReconnectAnchor/EdgeReconnectAnchor.svelte
EdgeReconnectAnchor[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/components/EdgeReconnectAnchor/EdgeReconnectAnchor.svelte";
function EdgeReconnectAnchor($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, EdgeReconnectAnchor);
  let reconnecting = prop($$props, "reconnecting", 15, false), size = prop($$props, "size", 3, 25), dragThreshold = prop($$props, "dragThreshold", 3, 1), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "type",
      "reconnecting",
      "position",
      "class",
      "size",
      "dragThreshold",
      "children"
    ],
    "rest"
  );
  const store = useStore();
  let edgeId = getContext("svelteflow__edge_id");
  if (!edgeId) {
    throw new Error("EdgeReconnectAnchor must be used within an Edge component");
  }
  const onPointerDown = (event2) => {
    if (strict_equals(event2.button, 0, false)) {
      return;
    }
    const {
      autoPanOnConnect,
      domNode,
      isValidConnection,
      connectionMode,
      connectionRadius,
      onconnectstart,
      onconnectend,
      onreconnect,
      onreconnectstart,
      onreconnectend,
      onbeforereconnect,
      cancelConnection,
      nodeLookup,
      flowId,
      panBy: panBy2,
      updateConnection,
      edgeLookup
    } = store;
    let newEdge;
    let edge = edgeLookup.get(edgeId);
    const _onConnectStart = (evt, params) => {
      reconnecting(true);
      onreconnectstart == null ? void 0 : onreconnectstart(event2, edge, $$props.type);
      onconnectstart == null ? void 0 : onconnectstart(evt, params);
    };
    const opposite = strict_equals($$props.type, "target") ? {
      nodeId: edge.source,
      handleId: edge.sourceHandle ?? null,
      type: "source"
    } : {
      nodeId: edge.target,
      handleId: edge.targetHandle ?? null,
      type: "target"
    };
    XYHandle.onPointerDown(event2, {
      autoPanOnConnect,
      connectionMode,
      connectionRadius,
      domNode,
      handleId: opposite.handleId,
      nodeId: opposite.nodeId,
      nodeLookup,
      isTarget: strict_equals(opposite.type, "target"),
      edgeUpdaterType: opposite.type,
      lib: "svelte",
      flowId,
      cancelConnection,
      panBy: panBy2,
      isValidConnection,
      onConnectStart: _onConnectStart,
      onConnectEnd: onconnectend,
      onConnect: (connection) => {
        newEdge = { ...edge, ...connection };
        newEdge = onbeforereconnect ? onbeforereconnect(newEdge, edge) ?? void 0 : newEdge;
        if (newEdge) {
          store.edges = store.edges.map((e) => strict_equals(e.id, edge.id) ? newEdge : e);
        }
        onreconnect == null ? void 0 : onreconnect(edge, connection);
      },
      onReconnectEnd: (event22, connectionState) => {
        reconnecting(false);
        onreconnectend == null ? void 0 : onreconnectend(event22, edge, opposite.type, connectionState);
      },
      updateConnection,
      getTransform: () => [
        store.viewport.x,
        store.viewport.y,
        store.viewport.zoom
      ],
      getFromHandle: () => store.connection.fromHandle,
      dragThreshold: dragThreshold() ?? store.connectionDragThreshold
    });
  };
  const expression = user_derived(() => {
    var _a;
    return (_a = $$props.position) == null ? void 0 : _a.x;
  });
  const expression_1 = user_derived(() => {
    var _a;
    return (_a = $$props.position) == null ? void 0 : _a.y;
  });
  const expression_2 = user_derived(() => [
    "svelte-flow__edgeupdater",
    `svelte-flow__edgeupdater-${$$props.type}`,
    store.noPanClass,
    $$props.class
  ]);
  EdgeLabel($$anchor, spread_props(
    {
      get x() {
        return get(expression);
      },
      get y() {
        return get(expression_1);
      },
      get width() {
        return size();
      },
      get height() {
        return size();
      },
      get class() {
        return get(expression_2);
      },
      onpointerdown: onPointerDown,
      transparent: true
    },
    () => rest,
    {
      children: wrap_snippet(EdgeReconnectAnchor, ($$anchor2, $$slotProps) => {
        var fragment_1 = comment();
        var node = first_child(fragment_1);
        {
          var consequent = ($$anchor3) => {
            var fragment_2 = comment();
            var node_1 = first_child(fragment_2);
            snippet(node_1, () => $$props.children);
            append($$anchor3, fragment_2);
          };
          if_block(node, ($$render) => {
            if (!reconnecting() && $$props.children) $$render(consequent);
          });
        }
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }
  ));
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/ControlButton.svelte
ControlButton[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/Controls/ControlButton.svelte";
var root18 = add_locations(from_html(`<button><!></button>`), ControlButton[FILENAME], [[14, 0]]);
function ControlButton($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, ControlButton);
  let restProps = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "class",
      "bgColor",
      "bgColorHover",
      "color",
      "colorHover",
      "borderColor",
      "onclick",
      "children"
    ],
    "restProps"
  );
  var button = root18();
  attribute_effect(button, () => ({
    type: "button",
    onclick: $$props.onclick,
    class: ["svelte-flow__controls-button", $$props.class],
    ...restProps,
    [STYLE]: {
      "--xy-controls-button-background-color-props": $$props.bgColor,
      "--xy-controls-button-background-color-hover-props": $$props.bgColorHover,
      "--xy-controls-button-color-props": $$props.color,
      "--xy-controls-button-color-hover-props": $$props.colorHover,
      "--xy-controls-button-border-color-props": $$props.borderColor
    }
  }));
  var node = child(button);
  snippet(node, () => $$props.children ?? noop);
  reset(button);
  append($$anchor, button);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Plus.svelte
Plus[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Plus.svelte";
var root19 = add_locations(from_svg(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z"></path></svg>`), Plus[FILENAME], [[1, 0, [[2, 2]]]]);
function Plus($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Plus);
  var svg = root19();
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Minus.svelte
Minus[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Minus.svelte";
var root20 = add_locations(from_svg(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 5"><path d="M0 0h32v4.2H0z"></path></svg>`), Minus[FILENAME], [[1, 0, [[2, 2]]]]);
function Minus($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Minus);
  var svg = root20();
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Fit.svelte
Fit[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Fit.svelte";
var root21 = add_locations(from_svg(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 30"><path d="M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z"></path></svg>`), Fit[FILENAME], [[1, 0, [[2, 2]]]]);
function Fit($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Fit);
  var svg = root21();
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Lock.svelte
Lock[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Lock.svelte";
var root22 = add_locations(from_svg(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 32"><path d="M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z"></path></svg>`), Lock[FILENAME], [[1, 0, [[2, 2]]]]);
function Lock($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Lock);
  var svg = root22();
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Unlock.svelte
Unlock[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Icons/Unlock.svelte";
var root23 = add_locations(from_svg(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 32"><path d="M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z"></path></svg>`), Unlock[FILENAME], [[1, 0, [[2, 2]]]]);
function Unlock($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Unlock);
  var svg = root23();
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Controls.svelte
Controls[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/Controls/Controls.svelte";
var root_34 = add_locations(from_html(`<!> <!>`, 1), Controls[FILENAME], []);
var root_110 = add_locations(from_html(`<!> <!> <!> <!> <!> <!>`, 1), Controls[FILENAME], []);
function Controls($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Controls);
  let position = prop($$props, "position", 3, "bottom-left"), orientation = prop($$props, "orientation", 3, "vertical"), showZoom = prop($$props, "showZoom", 3, true), showFitView = prop($$props, "showFitView", 3, true), showLock = prop($$props, "showLock", 3, true), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "position",
      "orientation",
      "showZoom",
      "showFitView",
      "showLock",
      "style",
      "class",
      "buttonBgColor",
      "buttonBgColorHover",
      "buttonColor",
      "buttonColorHover",
      "buttonBorderColor",
      "fitViewOptions",
      "children",
      "before",
      "after"
    ],
    "rest"
  );
  let store = tag(user_derived(useStore), "store");
  const buttonProps = {
    bgColor: $$props.buttonBgColor,
    bgColorHover: $$props.buttonBgColorHover,
    color: $$props.buttonColor,
    colorHover: $$props.buttonColorHover,
    borderColor: $$props.buttonBorderColor
  };
  let isInteractive = tag(user_derived(() => get(store).nodesDraggable || get(store).nodesConnectable || get(store).elementsSelectable), "isInteractive");
  let minZoomReached = tag(user_derived(() => get(store).viewport.zoom <= get(store).minZoom), "minZoomReached");
  let maxZoomReached = tag(user_derived(() => get(store).viewport.zoom >= get(store).maxZoom), "maxZoomReached");
  let ariaLabelConfig = tag(user_derived(() => get(store).ariaLabelConfig), "ariaLabelConfig");
  let orientationClass = tag(user_derived(() => strict_equals(orientation(), "horizontal") ? "horizontal" : "vertical"), "orientationClass");
  const onZoomInHandler = () => {
    get(store).zoomIn();
  };
  const onZoomOutHandler = () => {
    get(store).zoomOut();
  };
  const onFitViewHandler = () => {
    get(store).fitView($$props.fitViewOptions);
  };
  const onToggleInteractivity = () => {
    let interactive2 = !get(isInteractive);
    get(store).nodesDraggable = interactive2;
    get(store).nodesConnectable = interactive2;
    get(store).elementsSelectable = interactive2;
  };
  const expression = user_derived(() => [
    "svelte-flow__controls",
    get(orientationClass),
    $$props.class
  ]);
  Panel($$anchor, spread_props(
    {
      get class() {
        return get(expression);
      },
      get position() {
        return position();
      },
      "data-testid": "svelte-flow__controls",
      get "aria-label"() {
        return get(ariaLabelConfig)["controls.ariaLabel"];
      },
      get style() {
        return $$props.style;
      }
    },
    () => rest,
    {
      children: wrap_snippet(Controls, ($$anchor2, $$slotProps) => {
        var fragment_1 = root_110();
        var node = first_child(fragment_1);
        {
          var consequent = ($$anchor3) => {
            var fragment_2 = comment();
            var node_1 = first_child(fragment_2);
            snippet(node_1, () => $$props.before);
            append($$anchor3, fragment_2);
          };
          if_block(node, ($$render) => {
            if ($$props.before) $$render(consequent);
          });
        }
        var node_2 = sibling(node, 2);
        {
          var consequent_1 = ($$anchor3) => {
            var fragment_3 = root_34();
            var node_3 = first_child(fragment_3);
            ControlButton(node_3, spread_props(
              {
                onclick: onZoomInHandler,
                class: "svelte-flow__controls-zoomin",
                get title() {
                  return get(ariaLabelConfig)["controls.zoomIn.ariaLabel"];
                },
                get "aria-label"() {
                  return get(ariaLabelConfig)["controls.zoomIn.ariaLabel"];
                },
                get disabled() {
                  return get(maxZoomReached);
                }
              },
              () => buttonProps,
              {
                children: wrap_snippet(Controls, ($$anchor4, $$slotProps2) => {
                  Plus($$anchor4, {});
                }),
                $$slots: { default: true }
              }
            ));
            var node_4 = sibling(node_3, 2);
            ControlButton(node_4, spread_props(
              {
                onclick: onZoomOutHandler,
                class: "svelte-flow__controls-zoomout",
                get title() {
                  return get(ariaLabelConfig)["controls.zoomOut.ariaLabel"];
                },
                get "aria-label"() {
                  return get(ariaLabelConfig)["controls.zoomOut.ariaLabel"];
                },
                get disabled() {
                  return get(minZoomReached);
                }
              },
              () => buttonProps,
              {
                children: wrap_snippet(Controls, ($$anchor4, $$slotProps2) => {
                  Minus($$anchor4, {});
                }),
                $$slots: { default: true }
              }
            ));
            append($$anchor3, fragment_3);
          };
          if_block(node_2, ($$render) => {
            if (showZoom()) $$render(consequent_1);
          });
        }
        var node_5 = sibling(node_2, 2);
        {
          var consequent_2 = ($$anchor3) => {
            ControlButton($$anchor3, spread_props(
              {
                class: "svelte-flow__controls-fitview",
                onclick: onFitViewHandler,
                get title() {
                  return get(ariaLabelConfig)["controls.fitView.ariaLabel"];
                },
                get "aria-label"() {
                  return get(ariaLabelConfig)["controls.fitView.ariaLabel"];
                }
              },
              () => buttonProps,
              {
                children: wrap_snippet(Controls, ($$anchor4, $$slotProps2) => {
                  Fit($$anchor4, {});
                }),
                $$slots: { default: true }
              }
            ));
          };
          if_block(node_5, ($$render) => {
            if (showFitView()) $$render(consequent_2);
          });
        }
        var node_6 = sibling(node_5, 2);
        {
          var consequent_4 = ($$anchor3) => {
            ControlButton($$anchor3, spread_props(
              {
                class: "svelte-flow__controls-interactive",
                onclick: onToggleInteractivity,
                get title() {
                  return get(ariaLabelConfig)["controls.interactive.ariaLabel"];
                },
                get "aria-label"() {
                  return get(ariaLabelConfig)["controls.interactive.ariaLabel"];
                }
              },
              () => buttonProps,
              {
                children: wrap_snippet(Controls, ($$anchor4, $$slotProps2) => {
                  var fragment_9 = comment();
                  var node_7 = first_child(fragment_9);
                  {
                    var consequent_3 = ($$anchor5) => {
                      Unlock($$anchor5, {});
                    };
                    var alternate = ($$anchor5) => {
                      Lock($$anchor5, {});
                    };
                    if_block(node_7, ($$render) => {
                      if (get(isInteractive)) $$render(consequent_3);
                      else $$render(alternate, false);
                    });
                  }
                  append($$anchor4, fragment_9);
                }),
                $$slots: { default: true }
              }
            ));
          };
          if_block(node_6, ($$render) => {
            if (showLock()) $$render(consequent_4);
          });
        }
        var node_8 = sibling(node_6, 2);
        {
          var consequent_5 = ($$anchor3) => {
            var fragment_12 = comment();
            var node_9 = first_child(fragment_12);
            snippet(node_9, () => $$props.children);
            append($$anchor3, fragment_12);
          };
          if_block(node_8, ($$render) => {
            if ($$props.children) $$render(consequent_5);
          });
        }
        var node_10 = sibling(node_8, 2);
        {
          var consequent_6 = ($$anchor3) => {
            var fragment_13 = comment();
            var node_11 = first_child(fragment_13);
            snippet(node_11, () => $$props.after);
            append($$anchor3, fragment_13);
          };
          if_block(node_10, ($$render) => {
            if ($$props.after) $$render(consequent_6);
          });
        }
        append($$anchor2, fragment_1);
      }),
      $$slots: { default: true }
    }
  ));
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Background/types.js
var BackgroundVariant;
(function(BackgroundVariant2) {
  BackgroundVariant2["Lines"] = "lines";
  BackgroundVariant2["Dots"] = "dots";
  BackgroundVariant2["Cross"] = "cross";
})(BackgroundVariant || (BackgroundVariant = {}));

// node_modules/@xyflow/svelte/dist/lib/plugins/Background/DotPattern.svelte
DotPattern[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/Background/DotPattern.svelte";
var root24 = add_locations(from_svg(`<circle></circle>`), DotPattern[FILENAME], [[4, 0]]);
function DotPattern($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, DotPattern);
  var circle = root24();
  template_effect(() => {
    set_attribute(circle, "cx", $$props.radius);
    set_attribute(circle, "cy", $$props.radius);
    set_attribute(circle, "r", $$props.radius);
    set_class(circle, 0, clsx([
      "svelte-flow__background-pattern",
      "dots",
      $$props.class
    ]));
  });
  append($$anchor, circle);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Background/LinePattern.svelte
LinePattern[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/Background/LinePattern.svelte";
var root25 = add_locations(from_svg(`<path></path>`), LinePattern[FILENAME], [[9, 0]]);
function LinePattern($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, LinePattern);
  var path = root25();
  template_effect(() => {
    set_attribute(path, "stroke-width", $$props.lineWidth);
    set_attribute(path, "d", `M${$$props.dimensions[0] / 2} 0 V${$$props.dimensions[1]} M0 ${$$props.dimensions[1] / 2} H${$$props.dimensions[0]}`);
    set_class(path, 0, clsx([
      "svelte-flow__background-pattern",
      $$props.variant,
      $$props.class
    ]));
  });
  append($$anchor, path);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Background/Background.svelte
Background[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/Background/Background.svelte";
var defaultSize = {
  [BackgroundVariant.Dots]: 1,
  [BackgroundVariant.Lines]: 1,
  [BackgroundVariant.Cross]: 6
};
var root26 = add_locations(from_svg(`<svg data-testid="svelte-flow__background"><pattern patternUnits="userSpaceOnUse"><!></pattern><rect x="0" y="0" width="100%" height="100%"></rect></svg>`), Background[FILENAME], [[41, 0, [[47, 2], [62, 2]]]]);
function Background($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Background);
  let variant = prop($$props, "variant", 19, () => BackgroundVariant.Dots), gap = prop($$props, "gap", 3, 20), lineWidth = prop($$props, "lineWidth", 3, 1);
  let store = tag(user_derived(useStore), "store");
  let isDots = tag(user_derived(() => strict_equals(variant(), BackgroundVariant.Dots)), "isDots");
  let isCross = tag(user_derived(() => strict_equals(variant(), BackgroundVariant.Cross)), "isCross");
  let gapXY = tag(user_derived(() => Array.isArray(gap()) ? gap() : [gap(), gap()]), "gapXY");
  let patternId = tag(user_derived(() => `background-pattern-${get(store).flowId}-${$$props.id ?? ""}`), "patternId");
  let scaledGap = tag(
    user_derived(() => [
      get(gapXY)[0] * get(store).viewport.zoom || 1,
      get(gapXY)[1] * get(store).viewport.zoom || 1
    ]),
    "scaledGap"
  );
  let scaledSize = tag(user_derived(() => ($$props.size ?? defaultSize[variant()]) * get(store).viewport.zoom), "scaledSize");
  let patternDimensions = tag(user_derived(() => get(isCross) ? [get(scaledSize), get(scaledSize)] : get(scaledGap)), "patternDimensions");
  let patternOffset = tag(user_derived(() => get(isDots) ? [
    get(scaledSize) / 2,
    get(scaledSize) / 2
  ] : [
    get(patternDimensions)[0] / 2,
    get(patternDimensions)[1] / 2
  ]), "patternOffset");
  var svg = root26();
  let styles;
  var pattern = child(svg);
  var node = child(pattern);
  {
    var consequent = ($$anchor2) => {
      const expression = user_derived(() => get(scaledSize) / 2);
      DotPattern($$anchor2, {
        get radius() {
          return get(expression);
        },
        get class() {
          return $$props.patternClass;
        }
      });
    };
    var alternate = ($$anchor2) => {
      LinePattern($$anchor2, {
        get dimensions() {
          return get(patternDimensions);
        },
        get variant() {
          return variant();
        },
        get lineWidth() {
          return lineWidth();
        },
        get class() {
          return $$props.patternClass;
        }
      });
    };
    if_block(node, ($$render) => {
      if (get(isDots)) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  reset(pattern);
  var rect = sibling(pattern);
  reset(svg);
  template_effect(() => {
    set_class(svg, 0, clsx([
      "svelte-flow__background",
      "svelte-flow__container",
      $$props.class
    ]));
    styles = set_style(svg, "", styles, {
      "--xy-background-color-props": $$props.bgColor,
      "--xy-background-pattern-color-props": $$props.patternColor
    });
    set_attribute(pattern, "id", get(patternId));
    set_attribute(pattern, "x", get(store).viewport.x % get(scaledGap)[0]);
    set_attribute(pattern, "y", get(store).viewport.y % get(scaledGap)[1]);
    set_attribute(pattern, "width", get(scaledGap)[0]);
    set_attribute(pattern, "height", get(scaledGap)[1]);
    set_attribute(pattern, "patternTransform", `translate(-${get(patternOffset)[0]},-${get(patternOffset)[1]})`);
    set_attribute(rect, "fill", `url(#${get(patternId)})`);
  });
  append($$anchor, svg);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Minimap/MinimapNode.svelte
MinimapNode[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/Minimap/MinimapNode.svelte";
var root27 = add_locations(from_svg(`<rect></rect>`), MinimapNode[FILENAME], [[16, 0]]);
function MinimapNode($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, MinimapNode);
  let borderRadius = prop($$props, "borderRadius", 3, 5), strokeWidth = prop($$props, "strokeWidth", 3, 2);
  var rect = root27();
  let classes;
  let styles;
  template_effect(
    ($0) => {
      classes = set_class(rect, 0, clsx(["svelte-flow__minimap-node", $$props.class]), null, classes, $0);
      set_attribute(rect, "x", $$props.x);
      set_attribute(rect, "y", $$props.y);
      set_attribute(rect, "rx", borderRadius());
      set_attribute(rect, "ry", borderRadius());
      set_attribute(rect, "width", $$props.width);
      set_attribute(rect, "height", $$props.height);
      set_attribute(rect, "shape-rendering", $$props.shapeRendering);
      styles = set_style(rect, "", styles, {
        fill: $$props.color,
        stroke: $$props.strokeColor,
        "stroke-width": strokeWidth()
      });
    },
    [() => ({ selected: $$props.selected })]
  );
  append($$anchor, rect);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Minimap/interactive.js
function interactive(domNode, params) {
  const minimap = XYMinimap({
    domNode,
    panZoom: params.panZoom,
    getTransform: () => {
      const { viewport } = params.store;
      return [viewport.x, viewport.y, viewport.zoom];
    },
    getViewScale: params.getViewScale
  });
  minimap.update({
    translateExtent: params.translateExtent,
    width: params.width,
    height: params.height,
    inversePan: params.inversePan,
    zoomStep: params.zoomStep,
    pannable: params.pannable,
    zoomable: params.zoomable
  });
  function update(params2) {
    minimap.update({
      translateExtent: params2.translateExtent,
      width: params2.width,
      height: params2.height,
      inversePan: params2.inversePan,
      zoomStep: params2.zoomStep,
      pannable: params2.pannable,
      zoomable: params2.zoomable
    });
  }
  return {
    update,
    destroy() {
      minimap.destroy();
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/plugins/Minimap/Minimap.svelte
Minimap[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/Minimap/Minimap.svelte";
var getAttrFunction = (func) => func instanceof Function ? func : () => func;
var root_35 = add_locations(from_svg(`<title> </title>`), Minimap[FILENAME], [[104, 8]]);
var root_22 = add_locations(from_svg(`<svg class="svelte-flow__minimap-svg" role="img"><!><!><path class="svelte-flow__minimap-mask" fill-rule="evenodd" pointer-events="none"></path></svg>`), Minimap[FILENAME], [[78, 4, [[125, 6]]]]);
var root28 = add_locations(from_html(`<svelte-css-wrapper style="display: contents"><!></svelte-css-wrapper>`, 1), Minimap[FILENAME], [[70, 0]]);
function Minimap($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, Minimap);
  let position = prop($$props, "position", 3, "bottom-right"), nodeStrokeColor = prop($$props, "nodeStrokeColor", 3, "transparent"), nodeClass = prop($$props, "nodeClass", 3, ""), nodeBorderRadius = prop($$props, "nodeBorderRadius", 3, 5), nodeStrokeWidth = prop($$props, "nodeStrokeWidth", 3, 2), width = prop($$props, "width", 3, 200), height = prop($$props, "height", 3, 150), pannable = prop($$props, "pannable", 3, true), zoomable = prop($$props, "zoomable", 3, true), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "position",
      "ariaLabel",
      "nodeStrokeColor",
      "nodeColor",
      "nodeClass",
      "nodeBorderRadius",
      "nodeStrokeWidth",
      "bgColor",
      "maskColor",
      "maskStrokeColor",
      "maskStrokeWidth",
      "width",
      "height",
      "pannable",
      "zoomable",
      "inversePan",
      "zoomStep",
      "class"
    ],
    "rest"
  );
  let store = tag(user_derived(useStore), "store");
  let ariaLabelConfig = tag(user_derived(() => get(store).ariaLabelConfig), "ariaLabelConfig");
  const nodeColorFunc = strict_equals($$props.nodeColor, void 0) ? void 0 : getAttrFunction($$props.nodeColor);
  const nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor());
  const nodeClassFunc = getAttrFunction(nodeClass());
  const shapeRendering = (
    // @ts-expect-error - TS doesn't know about chrome
    strict_equals(typeof window, "undefined") || !!window.chrome ? "crispEdges" : "geometricPrecision"
  );
  let labelledBy = tag(user_derived(() => `svelte-flow__minimap-desc-${get(store).flowId}`), "labelledBy");
  let viewBB = tag(
    user_derived(() => ({
      x: -get(store).viewport.x / get(store).viewport.zoom,
      y: -get(store).viewport.y / get(store).viewport.zoom,
      width: get(store).width / get(store).viewport.zoom,
      height: get(store).height / get(store).viewport.zoom
    })),
    "viewBB"
  );
  let boundingRect = tag(user_derived(() => get(store).nodeLookup.size > 0 ? getBoundsOfRects(getInternalNodesBounds(get(store).nodeLookup, { filter: (n) => !n.hidden }), get(viewBB)) : get(viewBB)), "boundingRect");
  let scaledWidth = tag(user_derived(() => get(boundingRect).width / width()), "scaledWidth");
  let scaledHeight = tag(user_derived(() => get(boundingRect).height / height()), "scaledHeight");
  let viewScale = tag(user_derived(() => Math.max(get(scaledWidth), get(scaledHeight))), "viewScale");
  let viewWidth = tag(user_derived(() => get(viewScale) * width()), "viewWidth");
  let viewHeight = tag(user_derived(() => get(viewScale) * height()), "viewHeight");
  let offset = tag(user_derived(() => 5 * get(viewScale)), "offset");
  let x = tag(user_derived(() => get(boundingRect).x - (get(viewWidth) - get(boundingRect).width) / 2 - get(offset)), "x");
  let y = tag(user_derived(() => get(boundingRect).y - (get(viewHeight) - get(boundingRect).height) / 2 - get(offset)), "y");
  let viewboxWidth = tag(user_derived(() => get(viewWidth) + get(offset) * 2), "viewboxWidth");
  let viewboxHeight = tag(user_derived(() => get(viewHeight) + get(offset) * 2), "viewboxHeight");
  const getViewScale = () => get(viewScale);
  var fragment = root28();
  var node_1 = first_child(fragment);
  const expression = user_derived(() => ["svelte-flow__minimap", $$props.class]);
  {
    css_props(node_1, () => ({
      "--xy-minimap-background-color-props": $$props.bgColor
    }));
    Panel(node_1.lastChild, spread_props(
      {
        get position() {
          return position();
        },
        get class() {
          return get(expression);
        },
        "data-testid": "svelte-flow__minimap"
      },
      () => rest,
      {
        children: wrap_snippet(Minimap, ($$anchor2, $$slotProps) => {
          var fragment_1 = comment();
          var node_2 = first_child(fragment_1);
          {
            var consequent_2 = ($$anchor3) => {
              var svg = root_22();
              let styles;
              var node_3 = child(svg);
              {
                var consequent = ($$anchor4) => {
                  var title = root_35();
                  var text2 = child(title, true);
                  reset(title);
                  template_effect(() => {
                    set_attribute(title, "id", get(labelledBy));
                    set_text(text2, $$props.ariaLabel ?? get(ariaLabelConfig)["minimap.ariaLabel"]);
                  });
                  append($$anchor4, title);
                };
                if_block(node_3, ($$render) => {
                  if ($$props.ariaLabel ?? get(ariaLabelConfig)["minimap.ariaLabel"]) $$render(consequent);
                });
              }
              var node_4 = sibling(node_3);
              validate_each_keys(() => get(store).nodes, (userNode) => userNode.id);
              each(node_4, 17, () => get(store).nodes, (userNode) => userNode.id, ($$anchor4, userNode) => {
                var fragment_2 = comment();
                const node = user_derived(() => get(store).nodeLookup.get(get(userNode).id));
                get(node);
                var node_5 = first_child(fragment_2);
                {
                  var consequent_1 = ($$anchor5) => {
                    const nodeDimesions = user_derived(() => getNodeDimensions(get(node)));
                    get(nodeDimesions);
                    const expression_1 = user_derived(() => nodeColorFunc == null ? void 0 : nodeColorFunc(get(node)));
                    const expression_2 = user_derived(() => nodeStrokeColorFunc(get(node)));
                    const expression_3 = user_derived(() => nodeClassFunc(get(node)));
                    MinimapNode($$anchor5, spread_props(
                      {
                        get x() {
                          return get(node).internals.positionAbsolute.x;
                        },
                        get y() {
                          return get(node).internals.positionAbsolute.y;
                        }
                      },
                      () => get(nodeDimesions),
                      {
                        get selected() {
                          return get(node).selected;
                        },
                        get color() {
                          return get(expression_1);
                        },
                        get borderRadius() {
                          return nodeBorderRadius();
                        },
                        get strokeColor() {
                          return get(expression_2);
                        },
                        get strokeWidth() {
                          return nodeStrokeWidth();
                        },
                        get shapeRendering() {
                          return shapeRendering;
                        },
                        get class() {
                          return get(expression_3);
                        }
                      }
                    ));
                  };
                  if_block(node_5, ($$render) => {
                    if (get(node) && nodeHasDimensions(get(node))) $$render(consequent_1);
                  });
                }
                append($$anchor4, fragment_2);
              });
              var path = sibling(node_4);
              reset(svg);
              action(svg, ($$node, $$action_arg) => {
                var _a;
                return (_a = interactive) == null ? void 0 : _a($$node, $$action_arg);
              }, () => ({
                store: get(store),
                panZoom: get(store).panZoom,
                getViewScale,
                translateExtent: get(store).translateExtent,
                width: get(store).width,
                height: get(store).height,
                inversePan: $$props.inversePan,
                zoomStep: $$props.zoomStep,
                pannable: pannable(),
                zoomable: zoomable()
              }));
              template_effect(() => {
                set_attribute(svg, "width", width());
                set_attribute(svg, "height", height());
                set_attribute(svg, "viewBox", `${get(x) ?? ""} ${get(y) ?? ""} ${get(viewboxWidth) ?? ""} ${get(viewboxHeight) ?? ""}`);
                set_attribute(svg, "aria-labelledby", get(labelledBy));
                styles = set_style(svg, "", styles, {
                  "--xy-minimap-mask-background-color-props": $$props.maskColor,
                  "--xy-minimap-mask-stroke-color-props": $$props.maskStrokeColor,
                  "--xy-minimap-mask-stroke-width-props": $$props.maskStrokeWidth ? $$props.maskStrokeWidth * get(viewScale) : void 0
                });
                set_attribute(path, "d", `M${get(x) - get(offset)},${get(y) - get(offset)}h${get(viewboxWidth) + get(offset) * 2}v${get(viewboxHeight) + get(offset) * 2}h${-get(viewboxWidth) - get(offset) * 2}z
      M${get(viewBB).x ?? ""},${get(viewBB).y ?? ""}h${get(viewBB).width ?? ""}v${get(viewBB).height ?? ""}h${-get(viewBB).width}z`);
              });
              append($$anchor3, svg);
            };
            if_block(node_2, ($$render) => {
              if (get(store).panZoom) $$render(consequent_2);
            });
          }
          append($$anchor2, fragment_1);
        }),
        $$slots: { default: true }
      }
    ));
    reset(node_1);
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/plugins/NodeToolbar/NodeToolbar.svelte
NodeToolbar[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/NodeToolbar/NodeToolbar.svelte";
var root_111 = add_locations(from_html(`<div><!></div>`), NodeToolbar[FILENAME], [[46, 2]]);
function NodeToolbar($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, NodeToolbar);
  let position = prop($$props, "position", 19, () => Position.Top), align = prop($$props, "align", 3, "center"), offset = prop($$props, "offset", 3, 10), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "nodeId",
      "position",
      "align",
      "offset",
      "isVisible",
      "children"
    ],
    "rest"
  );
  const store = useStore();
  const { getNodesBounds: getNodesBounds2 } = useSvelteFlow();
  const contextNodeId = getContext("svelteflow__node_id");
  let toolbarNodes = tag(
    user_derived(() => {
      store.nodes;
      const nodeIds = Array.isArray($$props.nodeId) ? $$props.nodeId : [$$props.nodeId ?? contextNodeId];
      return nodeIds.reduce(
        (res, nodeId2) => {
          const node = store.nodeLookup.get(nodeId2);
          if (node) {
            res.push(node);
          }
          return res;
        },
        []
      );
    }),
    "toolbarNodes"
  );
  let transform = tag(
    user_derived(() => {
      const nodeRect = getNodesBounds2(get(toolbarNodes));
      if (nodeRect) {
        return getNodeToolbarTransform(nodeRect, store.viewport, position(), offset(), align());
      }
      return "";
    }),
    "transform"
  );
  let zIndex = tag(user_derived(() => strict_equals(get(toolbarNodes).length, 0) ? 1 : Math.max(...get(toolbarNodes).map((node) => (node.internals.z || 5) + 1))), "zIndex");
  let selectedNodesCount = tag(user_derived(() => store.nodes.filter((node) => node.selected).length), "selectedNodesCount");
  let isActive = tag(user_derived(() => strict_equals(typeof $$props.isVisible, "boolean") ? $$props.isVisible : strict_equals(get(toolbarNodes).length, 1) && get(toolbarNodes)[0].selected && strict_equals(get(selectedNodesCount), 1)), "isActive");
  var fragment = comment();
  var node_1 = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var div = root_111();
      attribute_effect(
        div,
        ($0, $1) => ({
          class: "svelte-flow__node-toolbar",
          "data-id": $0,
          ...rest,
          [STYLE]: {
            display: $1,
            position: "absolute",
            transform: get(transform),
            "z-index": get(zIndex)
          }
        }),
        [
          () => get(toolbarNodes).reduce((acc, node) => `${acc}${node.id} `, "").trim(),
          () => hideOnSSR().value ? "none" : void 0
        ]
      );
      var node_2 = child(div);
      snippet(node_2, () => $$props.children ?? noop);
      reset(div);
      action(div, ($$node, $$action_arg) => {
        var _a;
        return (_a = portal) == null ? void 0 : _a($$node, $$action_arg);
      }, () => "root");
      append($$anchor2, div);
    };
    if_block(node_1, ($$render) => {
      if (store.domNode && get(isActive) && get(toolbarNodes)) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/plugins/NodeResizer/ResizeControl.svelte
ResizeControl[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/NodeResizer/ResizeControl.svelte";
var root29 = add_locations(from_html(`<div><!></div>`), ResizeControl[FILENAME], [[102, 0]]);
function ResizeControl($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, ResizeControl);
  let variant = prop($$props, "variant", 19, () => ResizeControlVariant.Handle), minWidth = prop($$props, "minWidth", 3, 10), minHeight = prop($$props, "minHeight", 3, 10), maxWidth = prop($$props, "maxWidth", 19, () => Number.MAX_VALUE), maxHeight = prop($$props, "maxHeight", 19, () => Number.MAX_VALUE), keepAspectRatio = prop($$props, "keepAspectRatio", 3, false), autoScale = prop($$props, "autoScale", 3, true), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "nodeId",
      "position",
      "variant",
      "color",
      "minWidth",
      "minHeight",
      "maxWidth",
      "maxHeight",
      "keepAspectRatio",
      "autoScale",
      "shouldResize",
      "onResizeStart",
      "onResize",
      "onResizeEnd",
      "class",
      "children"
    ],
    "rest"
  );
  const store = useStore();
  let id = tag(user_derived(() => strict_equals(typeof $$props.nodeId, "string") ? $$props.nodeId : getContext("svelteflow__node_id")), "id");
  let resizeControlRef;
  let resizer = tag(state(null), "resizer");
  let isLineVariant = tag(user_derived(() => strict_equals(variant(), ResizeControlVariant.Line)), "isLineVariant");
  let controlPosition = tag(
    user_derived(() => {
      let defaultPosition = get(isLineVariant) ? "right" : "bottom-right";
      return $$props.position ?? defaultPosition;
    }),
    "controlPosition"
  );
  let positionClasses = tag(user_derived(() => get(controlPosition).split("-")), "positionClasses");
  onMount(() => {
    if (resizeControlRef) {
      set(
        resizer,
        XYResizer({
          domNode: resizeControlRef,
          nodeId: get(id),
          getStoreItems: () => {
            return {
              nodeLookup: store.nodeLookup,
              transform: [
                store.viewport.x,
                store.viewport.y,
                store.viewport.zoom
              ],
              snapGrid: store.snapGrid ?? void 0,
              snapToGrid: !!store.snapGrid,
              nodeOrigin: store.nodeOrigin,
              paneDomNode: store.domNode
            };
          },
          onChange: (change, childChanges) => {
            const changes = /* @__PURE__ */ new Map();
            let position2 = change.x && change.y ? { x: change.x, y: change.y } : void 0;
            changes.set(get(id), { ...change, position: position2 });
            for (const childChange of childChanges) {
              changes.set(childChange.id, { position: childChange.position });
            }
            store.nodes = store.nodes.map((node) => {
              var _a, _b;
              const change2 = changes.get(node.id);
              if (change2) {
                return {
                  ...node,
                  position: {
                    x: ((_a = change2.position) == null ? void 0 : _a.x) ?? node.position.x,
                    y: ((_b = change2.position) == null ? void 0 : _b.y) ?? node.position.y
                  },
                  width: change2.width ?? node.width,
                  height: change2.height ?? node.height
                };
              }
              return node;
            });
          }
        }),
        true
      );
    }
    return () => {
      var _a;
      (_a = get(resizer)) == null ? void 0 : _a.destroy();
    };
  });
  user_pre_effect(() => {
    var _a;
    (_a = get(resizer)) == null ? void 0 : _a.update({
      controlPosition: get(controlPosition),
      boundaries: {
        minWidth: minWidth(),
        minHeight: minHeight(),
        maxWidth: maxWidth(),
        maxHeight: maxHeight()
      },
      keepAspectRatio: !!keepAspectRatio(),
      onResizeStart: $$props.onResizeStart,
      onResize: $$props.onResize,
      onResizeEnd: $$props.onResizeEnd,
      shouldResize: $$props.shouldResize
    });
  });
  var div = root29();
  attribute_effect(
    div,
    ($0, $1) => ({
      class: $0,
      ...rest,
      [STYLE]: {
        "border-color": get(isLineVariant) ? $$props.color : void 0,
        "background-color": get(isLineVariant) ? void 0 : $$props.color,
        scale: $1
      }
    }),
    [
      () => [
        "svelte-flow__resize-control",
        store.noDragClass,
        ...get(positionClasses),
        variant(),
        $$props.class
      ],
      () => get(isLineVariant) || !autoScale() ? void 0 : Math.max(1 / store.viewport.zoom, 1)
    ]
  );
  var node_1 = child(div);
  snippet(node_1, () => $$props.children ?? noop);
  reset(div);
  bind_this(div, ($$value) => resizeControlRef = $$value, () => resizeControlRef);
  append($$anchor, div);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/plugins/NodeResizer/NodeResizer.svelte
NodeResizer[FILENAME] = "node_modules/@xyflow/svelte/dist/lib/plugins/NodeResizer/NodeResizer.svelte";
var root_112 = add_locations(from_html(`<!> <!>`, 1), NodeResizer[FILENAME], []);
function NodeResizer($$anchor, $$props) {
  check_target(new.target);
  push($$props, true, NodeResizer);
  let isVisible = prop($$props, "isVisible", 3, true), autoScale = prop($$props, "autoScale", 3, true), rest = rest_props(
    $$props,
    [
      "$$slots",
      "$$events",
      "$$legacy",
      "isVisible",
      "nodeId",
      "handleClass",
      "handleStyle",
      "lineClass",
      "lineStyle",
      "autoScale"
    ],
    "rest"
  );
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = root_112();
      var node_1 = first_child(fragment_1);
      validate_each_keys(() => XY_RESIZER_LINE_POSITIONS, (position) => position);
      each(node_1, 16, () => XY_RESIZER_LINE_POSITIONS, (position) => position, ($$anchor3, position) => {
        ResizeControl($$anchor3, spread_props(
          {
            get class() {
              return $$props.lineClass;
            },
            get style() {
              return $$props.lineStyle;
            },
            get nodeId() {
              return $$props.nodeId;
            },
            get position() {
              return position;
            },
            get autoScale() {
              return autoScale();
            },
            get variant() {
              return ResizeControlVariant.Line;
            }
          },
          () => rest
        ));
      });
      var node_2 = sibling(node_1, 2);
      validate_each_keys(() => XY_RESIZER_HANDLE_POSITIONS, (position) => position);
      each(node_2, 16, () => XY_RESIZER_HANDLE_POSITIONS, (position) => position, ($$anchor3, position) => {
        ResizeControl($$anchor3, spread_props(
          {
            get class() {
              return $$props.handleClass;
            },
            get style() {
              return $$props.handleStyle;
            },
            get nodeId() {
              return $$props.nodeId;
            },
            get position() {
              return position;
            },
            get autoScale() {
              return autoScale();
            }
          },
          () => rest
        ));
      });
      append($$anchor2, fragment_1);
    };
    if_block(node, ($$render) => {
      if (isVisible()) $$render(consequent);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useUpdateNodeInternals.svelte.js
function useUpdateNodeInternals() {
  const $$d = user_derived(useStore), domNode = user_derived(() => get($$d).domNode), updateNodeInternals2 = user_derived(() => get($$d).updateNodeInternals);
  const nodeId = getContext("svelteflow__node_id");
  const updateInternals = (id) => {
    if (!id && !nodeId) {
      throw new Error("When using outside of a node, you must provide an id.");
    }
    const updateIds = id ? Array.isArray(id) ? id : [id] : [nodeId];
    const updates = /* @__PURE__ */ new Map();
    updateIds.forEach((updateId) => {
      var _a;
      const nodeElement = (_a = get(domNode)) == null ? void 0 : _a.querySelector(`.svelte-flow__node[data-id="${updateId}"]`);
      if (nodeElement) {
        updates.set(updateId, { id: updateId, nodeElement, force: true });
      }
    });
    requestAnimationFrame(() => get(updateNodeInternals2)(updates));
  };
  return updateInternals;
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useConnection.svelte.js
function useConnection() {
  const $$d = user_derived(useStore), connection = user_derived(() => get($$d).connection);
  return {
    get current() {
      return get(connection);
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useNodesEdgesViewport.svelte.js
function useNodes() {
  const store = user_derived(useStore);
  return {
    get current() {
      return get(store).nodes;
    },
    set current(nodes) {
      get(store).nodes = nodes;
    },
    update(updateFn) {
      get(store).nodes = updateFn(get(store).nodes);
    },
    set(nodes) {
      get(store).nodes = nodes;
    }
  };
}
function useEdges() {
  const store = user_derived(useStore);
  return {
    get current() {
      return get(store).edges;
    },
    set current(edges) {
      get(store).edges = edges;
    },
    update(updateFn) {
      get(store).edges = updateFn(get(store).edges);
    },
    set(edges) {
      get(store).edges = edges;
    }
  };
}
function useViewport() {
  const store = user_derived(useStore);
  return {
    get current() {
      return get(store).viewport;
    },
    set current(viewport) {
      get(store).viewport = viewport;
    },
    update(updateFn) {
      get(store).viewport = updateFn(get(store).viewport);
    },
    set(viewport) {
      get(store).viewport = viewport;
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useNodeConnections.svelte.js
var initialConnections = [];
function useNodeConnections({
  id,
  handleType,
  handleId,
  onConnect,
  onDisconnect
} = {}) {
  const $$d = user_derived(useStore), edges = user_derived(() => get($$d).edges), connectionLookup = user_derived(() => get($$d).connectionLookup);
  const contextNodeId = getContext("svelteflow__node_id");
  const nodeId = id ?? contextNodeId;
  let connectionMaps = { previous: /* @__PURE__ */ new Map(), next: /* @__PURE__ */ new Map() };
  let connectionsArray = initialConnections;
  const connections = user_derived(() => {
    get(edges);
    const prevConnections = connectionMaps.next;
    const nextConnections = get(connectionLookup).get(`${nodeId}${handleType ? handleId ? `-${handleType}-${handleId}` : `-${handleType}` : ""}`) ?? /* @__PURE__ */ new Map();
    if (!areConnectionMapsEqual(nextConnections, prevConnections)) {
      connectionMaps = {
        previous: prevConnections,
        next: nextConnections
      };
      connectionsArray = Array.from(nextConnections.values() || initialConnections);
    }
    return connectionsArray;
  });
  user_effect(() => {
    if (onConnect) {
      get(connections);
      handleConnectionChange(connectionMaps.next, connectionMaps.previous, onConnect);
    }
    if (onDisconnect) {
      get(connections);
      handleConnectionChange(connectionMaps.previous, connectionMaps.next, onDisconnect);
    }
  });
  return {
    get current() {
      return get(connections);
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useNodesData.svelte.js
function useNodesData(nodeIds) {
  const $$d = user_derived(useStore), nodes = user_derived(() => get($$d).nodes), nodeLookup = user_derived(() => get($$d).nodeLookup);
  let prevNodesData = [];
  let initialRun = true;
  const nodeData = user_derived(() => {
    var _a;
    get(nodes);
    const nextNodesData = [];
    const isArrayOfIds = Array.isArray(nodeIds);
    const _nodeIds = isArrayOfIds ? nodeIds : [nodeIds];
    for (const nodeId of _nodeIds) {
      const node = (_a = get(nodeLookup).get(nodeId)) == null ? void 0 : _a.internals.userNode;
      if (node) {
        nextNodesData.push({
          id: node.id,
          type: node.type,
          data: node.data
        });
      }
    }
    if (!shallowNodeData(nextNodesData, prevNodesData) || initialRun) {
      prevNodesData = nextNodesData;
      initialRun = false;
    }
    return isArrayOfIds ? prevNodesData : prevNodesData[0] ?? null;
  });
  return {
    get current() {
      return get(nodeData);
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useInternalNode.svelte.js
function useInternalNode(id) {
  const $$d = user_derived(useStore), nodeLookup = user_derived(() => get($$d).nodeLookup), nodes = user_derived(() => get($$d).nodes);
  const node = user_derived(() => {
    get(nodes);
    return get(nodeLookup).get(id);
  });
  return {
    get current() {
      return get(node);
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useInitialized.svelte.js
function useNodesInitialized() {
  const $$d = user_derived(useStore), nodesInitialized = user_derived(() => get($$d).nodesInitialized);
  return {
    get current() {
      return get(nodesInitialized);
    }
  };
}
function useViewportInitialized() {
  const $$d_1 = user_derived(useStore), viewportInitialized = user_derived(() => get($$d_1).viewportInitialized);
  return {
    get current() {
      return get(viewportInitialized);
    }
  };
}

// node_modules/@xyflow/svelte/dist/lib/hooks/useOnSelectionChange.svelte.js
function useOnSelectionChange(onselectionchange) {
  const store = user_derived(useStore);
  const symbol = Symbol();
  user_effect(() => {
    get(store).selectionChangeHandlers.set(symbol, onselectionchange);
    return () => {
      get(store).selectionChangeHandlers.delete(symbol);
    };
  });
}
export {
  Background,
  BackgroundVariant,
  BaseEdge,
  BezierEdge,
  ConnectionLineType,
  ConnectionMode,
  ControlButton,
  Controls,
  EdgeLabel,
  EdgeReconnectAnchor,
  Handle,
  MarkerType,
  Minimap as MiniMap,
  ResizeControl as NodeResizeControl,
  NodeResizer,
  NodeToolbar,
  PanOnScrollMode,
  Panel,
  Position,
  ResizeControlVariant,
  SelectionMode,
  SmoothStepEdge,
  StepEdge,
  StraightEdge,
  SvelteFlow,
  SvelteFlowProvider,
  ViewportPortal,
  addEdge,
  arrowKeyDiffs,
  getBezierEdgeCenter,
  getBezierPath,
  getConnectedEdges,
  getEdgeCenter,
  getIncomers,
  getNodesBounds,
  getOutgoers,
  getSmoothStepPath,
  getStraightPath,
  getViewportForBounds,
  hideOnSSR,
  isEdge,
  isNode,
  portal,
  toPxString,
  useConnection,
  useEdges,
  useInternalNode,
  useNodeConnections,
  useNodes,
  useNodesData,
  useNodesInitialized,
  useOnSelectionChange,
  useStore,
  useSvelteFlow,
  useUpdateNodeInternals,
  useViewport,
  useViewportInitialized
};
//# sourceMappingURL=@xyflow_svelte.js.map
