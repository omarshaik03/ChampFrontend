import {
  createSubscriber,
  increment
} from "./chunk-3PGCAATA.js";
import {
  get,
  on,
  state,
  tag
} from "./chunk-SB6CT2W5.js";
import {
  true_default
} from "./chunk-UKRL22FA.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet
} from "./chunk-3HIFKDCR.js";

// node_modules/svelte/src/reactivity/reactive-value.js
var _fn, _subscribe;
var ReactiveValue = class {
  /**
   *
   * @param {() => T} fn
   * @param {(update: () => void) => void} onsubscribe
   */
  constructor(fn, onsubscribe) {
    __privateAdd(this, _fn);
    __privateAdd(this, _subscribe);
    __privateSet(this, _fn, fn);
    __privateSet(this, _subscribe, createSubscriber(onsubscribe));
  }
  get current() {
    __privateGet(this, _subscribe).call(this);
    return __privateGet(this, _fn).call(this);
  }
};
_fn = new WeakMap();
_subscribe = new WeakMap();

// node_modules/svelte/src/reactivity/media-query.js
var parenthesis_regex = /\(.+\)/;
var non_parenthesized_keywords = /* @__PURE__ */ new Set(["all", "print", "screen", "and", "or", "not", "only"]);
var MediaQuery = class extends ReactiveValue {
  /**
   * @param {string} query A media query string
   * @param {boolean} [fallback] Fallback value for the server
   */
  constructor(query, fallback) {
    let final_query = parenthesis_regex.test(query) || // we need to use `some` here because technically this `window.matchMedia('random,screen')` still returns true
    query.split(/[\s,]+/).some((keyword) => non_parenthesized_keywords.has(keyword.trim())) ? query : `(${query})`;
    const q = window.matchMedia(final_query);
    super(
      () => q.matches,
      (update) => on(q, "change", update)
    );
  }
};

// node_modules/svelte/src/reactivity/url-search-params.js
var REPLACE = Symbol();
var _version, _url, _updating, _SvelteURLSearchParams_instances, update_url_fn;
var SvelteURLSearchParams = class extends URLSearchParams {
  constructor() {
    super(...arguments);
    __privateAdd(this, _SvelteURLSearchParams_instances);
    __privateAdd(this, _version, true_default ? tag(state(0), "SvelteURLSearchParams version") : state(0));
    __privateAdd(this, _url, get_current_url());
    __privateAdd(this, _updating, false);
  }
  /**
   * @param {URLSearchParams} params
   * @internal
   */
  [REPLACE](params) {
    if (__privateGet(this, _updating)) return;
    __privateSet(this, _updating, true);
    for (const key of [...super.keys()]) {
      super.delete(key);
    }
    for (const [key, value] of params) {
      super.append(key, value);
    }
    increment(__privateGet(this, _version));
    __privateSet(this, _updating, false);
  }
  /**
   * @param {string} name
   * @param {string} value
   * @returns {void}
   */
  append(name, value) {
    super.append(name, value);
    __privateMethod(this, _SvelteURLSearchParams_instances, update_url_fn).call(this);
    increment(__privateGet(this, _version));
  }
  /**
   * @param {string} name
   * @param {string=} value
   * @returns {void}
   */
  delete(name, value) {
    var has_value = super.has(name, value);
    super.delete(name, value);
    if (has_value) {
      __privateMethod(this, _SvelteURLSearchParams_instances, update_url_fn).call(this);
      increment(__privateGet(this, _version));
    }
  }
  /**
   * @param {string} name
   * @returns {string|null}
   */
  get(name) {
    get(__privateGet(this, _version));
    return super.get(name);
  }
  /**
   * @param {string} name
   * @returns {string[]}
   */
  getAll(name) {
    get(__privateGet(this, _version));
    return super.getAll(name);
  }
  /**
   * @param {string} name
   * @param {string=} value
   * @returns {boolean}
   */
  has(name, value) {
    get(__privateGet(this, _version));
    return super.has(name, value);
  }
  keys() {
    get(__privateGet(this, _version));
    return super.keys();
  }
  /**
   * @param {string} name
   * @param {string} value
   * @returns {void}
   */
  set(name, value) {
    var previous = super.getAll(name).join("");
    super.set(name, value);
    if (previous !== super.getAll(name).join("")) {
      __privateMethod(this, _SvelteURLSearchParams_instances, update_url_fn).call(this);
      increment(__privateGet(this, _version));
    }
  }
  sort() {
    super.sort();
    __privateMethod(this, _SvelteURLSearchParams_instances, update_url_fn).call(this);
    increment(__privateGet(this, _version));
  }
  toString() {
    get(__privateGet(this, _version));
    return super.toString();
  }
  values() {
    get(__privateGet(this, _version));
    return super.values();
  }
  entries() {
    get(__privateGet(this, _version));
    return super.entries();
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get size() {
    get(__privateGet(this, _version));
    return super.size;
  }
};
_version = new WeakMap();
_url = new WeakMap();
_updating = new WeakMap();
_SvelteURLSearchParams_instances = new WeakSet();
update_url_fn = function() {
  if (!__privateGet(this, _url) || __privateGet(this, _updating)) return;
  __privateSet(this, _updating, true);
  const search = this.toString();
  __privateGet(this, _url).search = search && `?${search}`;
  __privateSet(this, _updating, false);
};

// node_modules/svelte/src/reactivity/url.js
var current_url = null;
function get_current_url() {
  return current_url;
}

export {
  MediaQuery
};
//# sourceMappingURL=chunk-3UHYETSG.js.map
